// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveSessions = `-- name: CountActiveSessions :one
SELECT COUNT(*) as count
FROM sessions
WHERE expires_at > CURRENT_TIMESTAMP
`

// アクティブなセッション数を取得
func (q *Queries) CountActiveSessions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSessions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLoginLog = `-- name: CreateLoginLog :exec
INSERT INTO login_logs (
    employee_id,
    employee_code,
    login_success,
    failure_reason,
    ip_address,
    user_agent
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateLoginLogParams struct {
	EmployeeID    *int32  `json:"employee_id"`
	EmployeeCode  *string `json:"employee_code"`
	LoginSuccess  bool    `json:"login_success"`
	FailureReason *string `json:"failure_reason"`
	IpAddress     *string `json:"ip_address"`
	UserAgent     *string `json:"user_agent"`
}

// ログイン履歴を記録
func (q *Queries) CreateLoginLog(ctx context.Context, arg CreateLoginLogParams) error {
	_, err := q.db.Exec(ctx, createLoginLog,
		arg.EmployeeID,
		arg.EmployeeCode,
		arg.LoginSuccess,
		arg.FailureReason,
		arg.IpAddress,
		arg.UserAgent,
	)
	return err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    employee_id,
    session_token,
    ip_address,
    user_agent,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, employee_id, session_token, ip_address, user_agent, expires_at, created_at, last_accessed_at
`

type CreateSessionParams struct {
	EmployeeID   int32              `json:"employee_id"`
	SessionToken string             `json:"session_token"`
	IpAddress    *string            `json:"ip_address"`
	UserAgent    *string            `json:"user_agent"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

// セッションを作成
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.EmployeeID,
		arg.SessionToken,
		arg.IpAddress,
		arg.UserAgent,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.SessionToken,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastAccessedAt,
	)
	return i, err
}

const deleteEmployeeSessions = `-- name: DeleteEmployeeSessions :exec
DELETE FROM sessions
WHERE employee_id = $1
`

// 特定従業員のすべてのセッションを削除
func (q *Queries) DeleteEmployeeSessions(ctx context.Context, employeeID int32) error {
	_, err := q.db.Exec(ctx, deleteEmployeeSessions, employeeID)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at < CURRENT_TIMESTAMP
`

// 期限切れセッションを削除
func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE session_token = $1
`

// セッションを削除（ログアウト）
func (q *Queries) DeleteSession(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, deleteSession, sessionToken)
	return err
}

const getActiveSessionsByEmployee = `-- name: GetActiveSessionsByEmployee :many
SELECT id, employee_id, session_token, ip_address, user_agent, expires_at, created_at, last_accessed_at
FROM sessions
WHERE employee_id = $1
AND expires_at > CURRENT_TIMESTAMP
ORDER BY created_at DESC
`

// 従業員のアクティブセッション一覧
func (q *Queries) GetActiveSessionsByEmployee(ctx context.Context, employeeID int32) ([]Session, error) {
	rows, err := q.db.Query(ctx, getActiveSessionsByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.SessionToken,
			&i.IpAddress,
			&i.UserAgent,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.LastAccessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeForLogin = `-- name: GetEmployeeForLogin :one

SELECT 
    e.id,
    e.employee_code,
    e.last_name,
    e.first_name,
    e.password_hash,
    e.role_id,
    r.name as role_name,
    e.failed_login_attempts,
    e.locked_until,
    e.last_login_at,
    e.is_active
FROM employees e
LEFT JOIN m_roles r ON e.role_id = r.id
WHERE e.employee_code = $1
AND e.deleted_at IS NULL
`

type GetEmployeeForLoginRow struct {
	ID                  int32              `json:"id"`
	EmployeeCode        string             `json:"employee_code"`
	LastName            string             `json:"last_name"`
	FirstName           string             `json:"first_name"`
	PasswordHash        *string            `json:"password_hash"`
	RoleID              *int32             `json:"role_id"`
	RoleName            *string            `json:"role_name"`
	FailedLoginAttempts *int32             `json:"failed_login_attempts"`
	LockedUntil         pgtype.Timestamptz `json:"locked_until"`
	LastLoginAt         pgtype.Timestamptz `json:"last_login_at"`
	IsActive            bool               `json:"is_active"`
}

// ==============================
// 認証・セッション管理クエリ
// ==============================
// 従業員コードでログイン情報を取得
func (q *Queries) GetEmployeeForLogin(ctx context.Context, employeeCode string) (GetEmployeeForLoginRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeForLogin, employeeCode)
	var i GetEmployeeForLoginRow
	err := row.Scan(
		&i.ID,
		&i.EmployeeCode,
		&i.LastName,
		&i.FirstName,
		&i.PasswordHash,
		&i.RoleID,
		&i.RoleName,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.LastLoginAt,
		&i.IsActive,
	)
	return i, err
}

const getLoginLogs = `-- name: GetLoginLogs :many
SELECT id, employee_id, employee_code, login_success, failure_reason, ip_address, user_agent, attempted_at
FROM login_logs
WHERE employee_id = $1
ORDER BY attempted_at DESC
LIMIT $2 OFFSET $3
`

type GetLoginLogsParams struct {
	EmployeeID *int32 `json:"employee_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

// ログイン履歴を取得
func (q *Queries) GetLoginLogs(ctx context.Context, arg GetLoginLogsParams) ([]LoginLog, error) {
	rows, err := q.db.Query(ctx, getLoginLogs, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginLog{}
	for rows.Next() {
		var i LoginLog
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.EmployeeCode,
			&i.LoginSuccess,
			&i.FailureReason,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLoginLogs = `-- name: GetRecentLoginLogs :many
SELECT 
    l.id, l.employee_id, l.employee_code, l.login_success, l.failure_reason, l.ip_address, l.user_agent, l.attempted_at,
    e.last_name,
    e.first_name
FROM login_logs l
LEFT JOIN employees e ON l.employee_id = e.id
ORDER BY l.attempted_at DESC
LIMIT $1 OFFSET $2
`

type GetRecentLoginLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentLoginLogsRow struct {
	ID            int32              `json:"id"`
	EmployeeID    *int32             `json:"employee_id"`
	EmployeeCode  *string            `json:"employee_code"`
	LoginSuccess  bool               `json:"login_success"`
	FailureReason *string            `json:"failure_reason"`
	IpAddress     *string            `json:"ip_address"`
	UserAgent     *string            `json:"user_agent"`
	AttemptedAt   pgtype.Timestamptz `json:"attempted_at"`
	LastName      *string            `json:"last_name"`
	FirstName     *string            `json:"first_name"`
}

// 最近のログイン履歴を取得（全従業員）
func (q *Queries) GetRecentLoginLogs(ctx context.Context, arg GetRecentLoginLogsParams) ([]GetRecentLoginLogsRow, error) {
	rows, err := q.db.Query(ctx, getRecentLoginLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentLoginLogsRow{}
	for rows.Next() {
		var i GetRecentLoginLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.EmployeeID,
			&i.EmployeeCode,
			&i.LoginSuccess,
			&i.FailureReason,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptedAt,
			&i.LastName,
			&i.FirstName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByToken = `-- name: GetSessionByToken :one
SELECT 
    s.id, s.employee_id, s.session_token, s.ip_address, s.user_agent, s.expires_at, s.created_at, s.last_accessed_at,
    e.employee_code,
    e.last_name,
    e.first_name,
    e.role_id,
    r.name as role_name
FROM sessions s
JOIN employees e ON s.employee_id = e.id
LEFT JOIN m_roles r ON e.role_id = r.id
WHERE s.session_token = $1
AND s.expires_at > CURRENT_TIMESTAMP
AND e.is_active = true
AND e.deleted_at IS NULL
`

type GetSessionByTokenRow struct {
	ID             int32              `json:"id"`
	EmployeeID     int32              `json:"employee_id"`
	SessionToken   string             `json:"session_token"`
	IpAddress      *string            `json:"ip_address"`
	UserAgent      *string            `json:"user_agent"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	LastAccessedAt pgtype.Timestamptz `json:"last_accessed_at"`
	EmployeeCode   string             `json:"employee_code"`
	LastName       string             `json:"last_name"`
	FirstName      string             `json:"first_name"`
	RoleID         *int32             `json:"role_id"`
	RoleName       *string            `json:"role_name"`
}

// セッショントークンでセッションを取得
func (q *Queries) GetSessionByToken(ctx context.Context, sessionToken string) (GetSessionByTokenRow, error) {
	row := q.db.QueryRow(ctx, getSessionByToken, sessionToken)
	var i GetSessionByTokenRow
	err := row.Scan(
		&i.ID,
		&i.EmployeeID,
		&i.SessionToken,
		&i.IpAddress,
		&i.UserAgent,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastAccessedAt,
		&i.EmployeeCode,
		&i.LastName,
		&i.FirstName,
		&i.RoleID,
		&i.RoleName,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE employees
SET 
    failed_login_attempts = failed_login_attempts + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// ログイン失敗回数をインクリメント
func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, incrementFailedLoginAttempts, id)
	return err
}

const lockEmployeeAccount = `-- name: LockEmployeeAccount :exec
UPDATE employees
SET 
    locked_until = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type LockEmployeeAccountParams struct {
	ID          int32              `json:"id"`
	LockedUntil pgtype.Timestamptz `json:"locked_until"`
}

// アカウントをロック
func (q *Queries) LockEmployeeAccount(ctx context.Context, arg LockEmployeeAccountParams) error {
	_, err := q.db.Exec(ctx, lockEmployeeAccount, arg.ID, arg.LockedUntil)
	return err
}

const updateEmployeePassword = `-- name: UpdateEmployeePassword :exec
UPDATE employees
SET 
    password_hash = $2,
    password_updated_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateEmployeePasswordParams struct {
	ID           int32   `json:"id"`
	PasswordHash *string `json:"password_hash"`
}

// パスワードを更新
func (q *Queries) UpdateEmployeePassword(ctx context.Context, arg UpdateEmployeePasswordParams) error {
	_, err := q.db.Exec(ctx, updateEmployeePassword, arg.ID, arg.PasswordHash)
	return err
}

const updateLoginSuccess = `-- name: UpdateLoginSuccess :exec
UPDATE employees
SET 
    last_login_at = CURRENT_TIMESTAMP,
    failed_login_attempts = 0,
    locked_until = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// ログイン成功時の更新
func (q *Queries) UpdateLoginSuccess(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateLoginSuccess, id)
	return err
}

const updateSessionAccess = `-- name: UpdateSessionAccess :exec
UPDATE sessions
SET last_accessed_at = CURRENT_TIMESTAMP
WHERE session_token = $1
`

// セッションの最終アクセス時刻を更新
func (q *Queries) UpdateSessionAccess(ctx context.Context, sessionToken string) error {
	_, err := q.db.Exec(ctx, updateSessionAccess, sessionToken)
	return err
}
