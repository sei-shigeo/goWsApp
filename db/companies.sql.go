// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: companies.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompanyOffice = `-- name: CreateCompanyOffice :one
INSERT INTO company_offices (
    company_id,
    office_code,
    office_name,
    office_type,
    manager_id,
    opening_date,
    postal_code,
    address,
    phone,
    fax,
    email,
    website,
    notes,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, company_id, office_code, office_name, office_type, manager_id, opening_date, closing_date, postal_code, address, phone, fax, email, website, image_url, notes, is_active, created_at, updated_at, deleted_at
`

type CreateCompanyOfficeParams struct {
	CompanyID   int32       `json:"company_id"`
	OfficeCode  *string     `json:"office_code"`
	OfficeName  string      `json:"office_name"`
	OfficeType  *string     `json:"office_type"`
	ManagerID   *int32      `json:"manager_id"`
	OpeningDate pgtype.Date `json:"opening_date"`
	PostalCode  *string     `json:"postal_code"`
	Address     *string     `json:"address"`
	Phone       *string     `json:"phone"`
	Fax         *string     `json:"fax"`
	Email       *string     `json:"email"`
	Website     *string     `json:"website"`
	Notes       *string     `json:"notes"`
	IsActive    *bool       `json:"is_active"`
}

// 事業所を登録
func (q *Queries) CreateCompanyOffice(ctx context.Context, arg CreateCompanyOfficeParams) (CompanyOffice, error) {
	row := q.db.QueryRow(ctx, createCompanyOffice,
		arg.CompanyID,
		arg.OfficeCode,
		arg.OfficeName,
		arg.OfficeType,
		arg.ManagerID,
		arg.OpeningDate,
		arg.PostalCode,
		arg.Address,
		arg.Phone,
		arg.Fax,
		arg.Email,
		arg.Website,
		arg.Notes,
		arg.IsActive,
	)
	var i CompanyOffice
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.OfficeCode,
		&i.OfficeName,
		&i.OfficeType,
		&i.ManagerID,
		&i.OpeningDate,
		&i.ClosingDate,
		&i.PostalCode,
		&i.Address,
		&i.Phone,
		&i.Fax,
		&i.Email,
		&i.Website,
		&i.ImageUrl,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCompanyOffice = `-- name: DeleteCompanyOffice :exec
UPDATE company_offices
SET
    deleted_at = CURRENT_TIMESTAMP,
    is_active = false
WHERE id = $1
`

// 事業所を論理削除
func (q *Queries) DeleteCompanyOffice(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCompanyOffice, id)
	return err
}

const getCompany = `-- name: GetCompany :one

SELECT id, name, company_code, transport_license_number, transport_license_type, transport_license_issue_date, transport_license_expiry_date, transport_license_image_url, tax_id, established_date, capital_stock, representative_name, representative_name_kana, representative_name_en, invoice_number, is_active, created_at, updated_at, deleted_at
FROM companies
WHERE id = $1
AND deleted_at IS NULL
`

// ==============================
// 会社情報・事業所管理クエリ
// ==============================
// 会社情報を取得
func (q *Queries) GetCompany(ctx context.Context, id int32) (Company, error) {
	row := q.db.QueryRow(ctx, getCompany, id)
	var i Company
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CompanyCode,
		&i.TransportLicenseNumber,
		&i.TransportLicenseType,
		&i.TransportLicenseIssueDate,
		&i.TransportLicenseExpiryDate,
		&i.TransportLicenseImageUrl,
		&i.TaxID,
		&i.EstablishedDate,
		&i.CapitalStock,
		&i.RepresentativeName,
		&i.RepresentativeNameKana,
		&i.RepresentativeNameEn,
		&i.InvoiceNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCompanyOffice = `-- name: GetCompanyOffice :one
SELECT 
    o.id, o.company_id, o.office_code, o.office_name, o.office_type, o.manager_id, o.opening_date, o.closing_date, o.postal_code, o.address, o.phone, o.fax, o.email, o.website, o.image_url, o.notes, o.is_active, o.created_at, o.updated_at, o.deleted_at,
    e.last_name || ' ' || e.first_name as manager_name
FROM company_offices o
LEFT JOIN employees e ON o.manager_id = e.id
WHERE o.id = $1
AND o.deleted_at IS NULL
`

type GetCompanyOfficeRow struct {
	ID          int32              `json:"id"`
	CompanyID   int32              `json:"company_id"`
	OfficeCode  *string            `json:"office_code"`
	OfficeName  string             `json:"office_name"`
	OfficeType  *string            `json:"office_type"`
	ManagerID   *int32             `json:"manager_id"`
	OpeningDate pgtype.Date        `json:"opening_date"`
	ClosingDate pgtype.Date        `json:"closing_date"`
	PostalCode  *string            `json:"postal_code"`
	Address     *string            `json:"address"`
	Phone       *string            `json:"phone"`
	Fax         *string            `json:"fax"`
	Email       *string            `json:"email"`
	Website     *string            `json:"website"`
	ImageUrl    *string            `json:"image_url"`
	Notes       *string            `json:"notes"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	ManagerName interface{}        `json:"manager_name"`
}

// 事業所を取得
func (q *Queries) GetCompanyOffice(ctx context.Context, id int32) (GetCompanyOfficeRow, error) {
	row := q.db.QueryRow(ctx, getCompanyOffice, id)
	var i GetCompanyOfficeRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.OfficeCode,
		&i.OfficeName,
		&i.OfficeType,
		&i.ManagerID,
		&i.OpeningDate,
		&i.ClosingDate,
		&i.PostalCode,
		&i.Address,
		&i.Phone,
		&i.Fax,
		&i.Email,
		&i.Website,
		&i.ImageUrl,
		&i.Notes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ManagerName,
	)
	return i, err
}

const listActiveCompanyOffices = `-- name: ListActiveCompanyOffices :many
SELECT 
    o.id, o.company_id, o.office_code, o.office_name, o.office_type, o.manager_id, o.opening_date, o.closing_date, o.postal_code, o.address, o.phone, o.fax, o.email, o.website, o.image_url, o.notes, o.is_active, o.created_at, o.updated_at, o.deleted_at,
    e.last_name || ' ' || e.first_name as manager_name
FROM company_offices o
LEFT JOIN employees e ON o.manager_id = e.id
WHERE o.is_active = true
AND o.deleted_at IS NULL
ORDER BY o.office_code
`

type ListActiveCompanyOfficesRow struct {
	ID          int32              `json:"id"`
	CompanyID   int32              `json:"company_id"`
	OfficeCode  *string            `json:"office_code"`
	OfficeName  string             `json:"office_name"`
	OfficeType  *string            `json:"office_type"`
	ManagerID   *int32             `json:"manager_id"`
	OpeningDate pgtype.Date        `json:"opening_date"`
	ClosingDate pgtype.Date        `json:"closing_date"`
	PostalCode  *string            `json:"postal_code"`
	Address     *string            `json:"address"`
	Phone       *string            `json:"phone"`
	Fax         *string            `json:"fax"`
	Email       *string            `json:"email"`
	Website     *string            `json:"website"`
	ImageUrl    *string            `json:"image_url"`
	Notes       *string            `json:"notes"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	ManagerName interface{}        `json:"manager_name"`
}

// アクティブな事業所一覧
func (q *Queries) ListActiveCompanyOffices(ctx context.Context) ([]ListActiveCompanyOfficesRow, error) {
	rows, err := q.db.Query(ctx, listActiveCompanyOffices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveCompanyOfficesRow{}
	for rows.Next() {
		var i ListActiveCompanyOfficesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.OfficeCode,
			&i.OfficeName,
			&i.OfficeType,
			&i.ManagerID,
			&i.OpeningDate,
			&i.ClosingDate,
			&i.PostalCode,
			&i.Address,
			&i.Phone,
			&i.Fax,
			&i.Email,
			&i.Website,
			&i.ImageUrl,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ManagerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCompanyOffices = `-- name: ListCompanyOffices :many
SELECT 
    o.id, o.company_id, o.office_code, o.office_name, o.office_type, o.manager_id, o.opening_date, o.closing_date, o.postal_code, o.address, o.phone, o.fax, o.email, o.website, o.image_url, o.notes, o.is_active, o.created_at, o.updated_at, o.deleted_at,
    e.last_name || ' ' || e.first_name as manager_name
FROM company_offices o
LEFT JOIN employees e ON o.manager_id = e.id
WHERE o.deleted_at IS NULL
ORDER BY o.office_code
`

type ListCompanyOfficesRow struct {
	ID          int32              `json:"id"`
	CompanyID   int32              `json:"company_id"`
	OfficeCode  *string            `json:"office_code"`
	OfficeName  string             `json:"office_name"`
	OfficeType  *string            `json:"office_type"`
	ManagerID   *int32             `json:"manager_id"`
	OpeningDate pgtype.Date        `json:"opening_date"`
	ClosingDate pgtype.Date        `json:"closing_date"`
	PostalCode  *string            `json:"postal_code"`
	Address     *string            `json:"address"`
	Phone       *string            `json:"phone"`
	Fax         *string            `json:"fax"`
	Email       *string            `json:"email"`
	Website     *string            `json:"website"`
	ImageUrl    *string            `json:"image_url"`
	Notes       *string            `json:"notes"`
	IsActive    *bool              `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
	ManagerName interface{}        `json:"manager_name"`
}

// 事業所一覧
func (q *Queries) ListCompanyOffices(ctx context.Context) ([]ListCompanyOfficesRow, error) {
	rows, err := q.db.Query(ctx, listCompanyOffices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCompanyOfficesRow{}
	for rows.Next() {
		var i ListCompanyOfficesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.OfficeCode,
			&i.OfficeName,
			&i.OfficeType,
			&i.ManagerID,
			&i.OpeningDate,
			&i.ClosingDate,
			&i.PostalCode,
			&i.Address,
			&i.Phone,
			&i.Fax,
			&i.Email,
			&i.Website,
			&i.ImageUrl,
			&i.Notes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ManagerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompany = `-- name: UpdateCompany :exec
UPDATE companies
SET
    name = COALESCE($1, name),
    company_code = COALESCE($2, company_code),
    transport_license_number = COALESCE($3, transport_license_number),
    transport_license_type = COALESCE($4, transport_license_type),
    transport_license_issue_date = COALESCE($5, transport_license_issue_date),
    transport_license_expiry_date = COALESCE($6, transport_license_expiry_date),
    tax_id = COALESCE($7, tax_id),
    invoice_number = COALESCE($8, invoice_number),
    representative_name = COALESCE($9, representative_name),
    is_active = COALESCE($10, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $11
`

type UpdateCompanyParams struct {
	Name                       *string     `json:"name"`
	CompanyCode                *string     `json:"company_code"`
	TransportLicenseNumber     *string     `json:"transport_license_number"`
	TransportLicenseType       *string     `json:"transport_license_type"`
	TransportLicenseIssueDate  pgtype.Date `json:"transport_license_issue_date"`
	TransportLicenseExpiryDate pgtype.Date `json:"transport_license_expiry_date"`
	TaxID                      *string     `json:"tax_id"`
	InvoiceNumber              *string     `json:"invoice_number"`
	RepresentativeName         *string     `json:"representative_name"`
	IsActive                   *bool       `json:"is_active"`
	ID                         int32       `json:"id"`
}

// 会社情報を更新
func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) error {
	_, err := q.db.Exec(ctx, updateCompany,
		arg.Name,
		arg.CompanyCode,
		arg.TransportLicenseNumber,
		arg.TransportLicenseType,
		arg.TransportLicenseIssueDate,
		arg.TransportLicenseExpiryDate,
		arg.TaxID,
		arg.InvoiceNumber,
		arg.RepresentativeName,
		arg.IsActive,
		arg.ID,
	)
	return err
}

const updateCompanyOffice = `-- name: UpdateCompanyOffice :exec
UPDATE company_offices
SET
    office_name = COALESCE($1, office_name),
    office_type = COALESCE($2, office_type),
    manager_id = COALESCE($3, manager_id),
    postal_code = COALESCE($4, postal_code),
    address = COALESCE($5, address),
    phone = COALESCE($6, phone),
    fax = COALESCE($7, fax),
    email = COALESCE($8, email),
    website = COALESCE($9, website),
    notes = COALESCE($10, notes),
    is_active = COALESCE($11, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $12
`

type UpdateCompanyOfficeParams struct {
	OfficeName *string `json:"office_name"`
	OfficeType *string `json:"office_type"`
	ManagerID  *int32  `json:"manager_id"`
	PostalCode *string `json:"postal_code"`
	Address    *string `json:"address"`
	Phone      *string `json:"phone"`
	Fax        *string `json:"fax"`
	Email      *string `json:"email"`
	Website    *string `json:"website"`
	Notes      *string `json:"notes"`
	IsActive   *bool   `json:"is_active"`
	ID         int32   `json:"id"`
}

// 事業所を更新
func (q *Queries) UpdateCompanyOffice(ctx context.Context, arg UpdateCompanyOfficeParams) error {
	_, err := q.db.Exec(ctx, updateCompanyOffice,
		arg.OfficeName,
		arg.OfficeType,
		arg.ManagerID,
		arg.PostalCode,
		arg.Address,
		arg.Phone,
		arg.Fax,
		arg.Email,
		arg.Website,
		arg.Notes,
		arg.IsActive,
		arg.ID,
	)
	return err
}
