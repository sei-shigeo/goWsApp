// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: customers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCustomers = `-- name: CountCustomers :one
SELECT COUNT(*) as count
FROM customers
WHERE deleted_at IS NULL
AND ($1::boolean IS NULL OR is_active = $1)
`

// 取引先数をカウント
func (q *Queries) CountCustomers(ctx context.Context, dollar_1 bool) (int64, error) {
	row := q.db.QueryRow(ctx, countCustomers, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCustomer = `-- name: CreateCustomer :one

INSERT INTO customers (
    name,
    customer_code,
    credit_limit,
    payment_terms,
    payment_method,
    closing_day,
    payment_due_day,
    invoice_number,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
`

type CreateCustomerParams struct {
	Name          string         `json:"name"`
	CustomerCode  string         `json:"customer_code"`
	CreditLimit   pgtype.Numeric `json:"credit_limit"`
	PaymentTerms  *string        `json:"payment_terms"`
	PaymentMethod *string        `json:"payment_method"`
	ClosingDay    *int32         `json:"closing_day"`
	PaymentDueDay *int32         `json:"payment_due_day"`
	InvoiceNumber *string        `json:"invoice_number"`
	IsActive      *bool          `json:"is_active"`
}

// ==============================
// 取引先管理クエリ
// ==============================
// 取引先を新規登録
func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.Name,
		arg.CustomerCode,
		arg.CreditLimit,
		arg.PaymentTerms,
		arg.PaymentMethod,
		arg.ClosingDay,
		arg.PaymentDueDay,
		arg.InvoiceNumber,
		arg.IsActive,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CustomerCode,
		&i.CreditLimit,
		&i.PaymentTerms,
		&i.PaymentMethod,
		&i.ClosingDay,
		&i.PaymentDueDay,
		&i.InvoiceNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createCustomerContact = `-- name: CreateCustomerContact :one
INSERT INTO customer_contacts (
    customer_id,
    last_name,
    first_name,
    last_name_kana,
    first_name_kana,
    department,
    position,
    email,
    phone_direct,
    phone_mobile,
    is_primary,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, customer_id, contact_code, last_name, first_name, last_name_kana, first_name_kana, department, position, office_location, email, phone_direct, phone_mobile, phone_extension, is_primary, is_active, notes, created_at, updated_at
`

type CreateCustomerContactParams struct {
	CustomerID    int32   `json:"customer_id"`
	LastName      string  `json:"last_name"`
	FirstName     string  `json:"first_name"`
	LastNameKana  *string `json:"last_name_kana"`
	FirstNameKana *string `json:"first_name_kana"`
	Department    *string `json:"department"`
	Position      *string `json:"position"`
	Email         *string `json:"email"`
	PhoneDirect   *string `json:"phone_direct"`
	PhoneMobile   *string `json:"phone_mobile"`
	IsPrimary     *bool   `json:"is_primary"`
	Notes         *string `json:"notes"`
}

// 取引先担当者を登録
func (q *Queries) CreateCustomerContact(ctx context.Context, arg CreateCustomerContactParams) (CustomerContact, error) {
	row := q.db.QueryRow(ctx, createCustomerContact,
		arg.CustomerID,
		arg.LastName,
		arg.FirstName,
		arg.LastNameKana,
		arg.FirstNameKana,
		arg.Department,
		arg.Position,
		arg.Email,
		arg.PhoneDirect,
		arg.PhoneMobile,
		arg.IsPrimary,
		arg.Notes,
	)
	var i CustomerContact
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ContactCode,
		&i.LastName,
		&i.FirstName,
		&i.LastNameKana,
		&i.FirstNameKana,
		&i.Department,
		&i.Position,
		&i.OfficeLocation,
		&i.Email,
		&i.PhoneDirect,
		&i.PhoneMobile,
		&i.PhoneExtension,
		&i.IsPrimary,
		&i.IsActive,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
UPDATE customers
SET
    deleted_at = CURRENT_TIMESTAMP,
    is_active = false
WHERE id = $1
`

// 取引先を論理削除
func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const deleteCustomerContact = `-- name: DeleteCustomerContact :exec
DELETE FROM customer_contacts
WHERE id = $1
`

// 取引先担当者を削除
func (q *Queries) DeleteCustomerContact(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomerContact, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
FROM customers
WHERE id = $1
AND deleted_at IS NULL
`

// 取引先をIDで取得
func (q *Queries) GetCustomer(ctx context.Context, id int32) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CustomerCode,
		&i.CreditLimit,
		&i.PaymentTerms,
		&i.PaymentMethod,
		&i.ClosingDay,
		&i.PaymentDueDay,
		&i.InvoiceNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomerByCode = `-- name: GetCustomerByCode :one
SELECT id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
FROM customers
WHERE customer_code = $1
AND deleted_at IS NULL
`

// 取引先コードで取得
func (q *Queries) GetCustomerByCode(ctx context.Context, customerCode string) (Customer, error) {
	row := q.db.QueryRow(ctx, getCustomerByCode, customerCode)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CustomerCode,
		&i.CreditLimit,
		&i.PaymentTerms,
		&i.PaymentMethod,
		&i.ClosingDay,
		&i.PaymentDueDay,
		&i.InvoiceNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCustomerContact = `-- name: GetCustomerContact :one
SELECT id, customer_id, contact_code, last_name, first_name, last_name_kana, first_name_kana, department, position, office_location, email, phone_direct, phone_mobile, phone_extension, is_primary, is_active, notes, created_at, updated_at
FROM customer_contacts
WHERE id = $1
`

// 取引先担当者を取得
func (q *Queries) GetCustomerContact(ctx context.Context, id int32) (CustomerContact, error) {
	row := q.db.QueryRow(ctx, getCustomerContact, id)
	var i CustomerContact
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ContactCode,
		&i.LastName,
		&i.FirstName,
		&i.LastNameKana,
		&i.FirstNameKana,
		&i.Department,
		&i.Position,
		&i.OfficeLocation,
		&i.Email,
		&i.PhoneDirect,
		&i.PhoneMobile,
		&i.PhoneExtension,
		&i.IsPrimary,
		&i.IsActive,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerWithContacts = `-- name: GetCustomerWithContacts :one
SELECT 
    c.id, c.name, c.customer_code, c.credit_limit, c.payment_terms, c.payment_method, c.closing_day, c.payment_due_day, c.invoice_number, c.is_active, c.created_at, c.updated_at, c.deleted_at,
    json_agg(
        json_build_object(
            'id', cc.id,
            'last_name', cc.last_name,
            'first_name', cc.first_name,
            'department', cc.department,
            'position', cc.position,
            'phone_direct', cc.phone_direct,
            'email', cc.email
        ) ORDER BY cc.is_primary DESC, cc.last_name
    ) FILTER (WHERE cc.id IS NOT NULL) as contacts
FROM customers c
LEFT JOIN customer_contacts cc ON c.id = cc.customer_id
WHERE c.id = $1
GROUP BY c.id
`

type GetCustomerWithContactsRow struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	CustomerCode  string             `json:"customer_code"`
	CreditLimit   pgtype.Numeric     `json:"credit_limit"`
	PaymentTerms  *string            `json:"payment_terms"`
	PaymentMethod *string            `json:"payment_method"`
	ClosingDay    *int32             `json:"closing_day"`
	PaymentDueDay *int32             `json:"payment_due_day"`
	InvoiceNumber *string            `json:"invoice_number"`
	IsActive      *bool              `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
	Contacts      []byte             `json:"contacts"`
}

// 取引先と担当者情報を取得
func (q *Queries) GetCustomerWithContacts(ctx context.Context, id int32) (GetCustomerWithContactsRow, error) {
	row := q.db.QueryRow(ctx, getCustomerWithContacts, id)
	var i GetCustomerWithContactsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CustomerCode,
		&i.CreditLimit,
		&i.PaymentTerms,
		&i.PaymentMethod,
		&i.ClosingDay,
		&i.PaymentDueDay,
		&i.InvoiceNumber,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Contacts,
	)
	return i, err
}

const listActiveCustomers = `-- name: ListActiveCustomers :many
SELECT id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
FROM customers
WHERE is_active = true
AND deleted_at IS NULL
ORDER BY customer_code
`

// アクティブな取引先一覧
func (q *Queries) ListActiveCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listActiveCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CustomerCode,
			&i.CreditLimit,
			&i.PaymentTerms,
			&i.PaymentMethod,
			&i.ClosingDay,
			&i.PaymentDueDay,
			&i.InvoiceNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerContacts = `-- name: ListCustomerContacts :many
SELECT id, customer_id, contact_code, last_name, first_name, last_name_kana, first_name_kana, department, position, office_location, email, phone_direct, phone_mobile, phone_extension, is_primary, is_active, notes, created_at, updated_at
FROM customer_contacts
WHERE customer_id = $1
ORDER BY is_primary DESC, last_name
`

// 取引先の担当者一覧
func (q *Queries) ListCustomerContacts(ctx context.Context, customerID int32) ([]CustomerContact, error) {
	rows, err := q.db.Query(ctx, listCustomerContacts, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CustomerContact{}
	for rows.Next() {
		var i CustomerContact
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ContactCode,
			&i.LastName,
			&i.FirstName,
			&i.LastNameKana,
			&i.FirstNameKana,
			&i.Department,
			&i.Position,
			&i.OfficeLocation,
			&i.Email,
			&i.PhoneDirect,
			&i.PhoneMobile,
			&i.PhoneExtension,
			&i.IsPrimary,
			&i.IsActive,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
FROM customers
WHERE deleted_at IS NULL
ORDER BY customer_code
LIMIT $1 OFFSET $2
`

type ListCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// 取引先一覧を取得
func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, listCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CustomerCode,
			&i.CreditLimit,
			&i.PaymentTerms,
			&i.PaymentMethod,
			&i.ClosingDay,
			&i.PaymentDueDay,
			&i.InvoiceNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomers = `-- name: SearchCustomers :many
SELECT id, name, customer_code, credit_limit, payment_terms, payment_method, closing_day, payment_due_day, invoice_number, is_active, created_at, updated_at, deleted_at
FROM customers
WHERE deleted_at IS NULL
AND (
    $1::text IS NULL 
    OR customer_code ILIKE '%' || $1 || '%'
    OR name ILIKE '%' || $1 || '%'
)
AND ($2::boolean IS NULL OR is_active = $2)
ORDER BY customer_code
LIMIT $3 OFFSET $4
`

type SearchCustomersParams struct {
	Column1 string `json:"column_1"`
	Column2 bool   `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

// 取引先を検索
func (q *Queries) SearchCustomers(ctx context.Context, arg SearchCustomersParams) ([]Customer, error) {
	rows, err := q.db.Query(ctx, searchCustomers,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CustomerCode,
			&i.CreditLimit,
			&i.PaymentTerms,
			&i.PaymentMethod,
			&i.ClosingDay,
			&i.PaymentDueDay,
			&i.InvoiceNumber,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPrimaryContact = `-- name: SetPrimaryContact :exec
UPDATE customer_contacts
SET 
    is_primary = CASE WHEN id = $2 THEN true ELSE false END,
    updated_at = CURRENT_TIMESTAMP
WHERE customer_id = $1
AND deleted_at IS NULL
`

type SetPrimaryContactParams struct {
	CustomerID int32 `json:"customer_id"`
	ID         int32 `json:"id"`
}

// メイン担当者を設定（他の担当者のis_primaryをfalseにする）
func (q *Queries) SetPrimaryContact(ctx context.Context, arg SetPrimaryContactParams) error {
	_, err := q.db.Exec(ctx, setPrimaryContact, arg.CustomerID, arg.ID)
	return err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customers
SET
    name = COALESCE($1, name),
    credit_limit = COALESCE($2, credit_limit),
    payment_terms = COALESCE($3, payment_terms),
    payment_method = COALESCE($4, payment_method),
    closing_day = COALESCE($5, closing_day),
    payment_due_day = COALESCE($6, payment_due_day),
    invoice_number = COALESCE($7, invoice_number),
    is_active = COALESCE($8, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $9
`

type UpdateCustomerParams struct {
	Name          *string        `json:"name"`
	CreditLimit   pgtype.Numeric `json:"credit_limit"`
	PaymentTerms  *string        `json:"payment_terms"`
	PaymentMethod *string        `json:"payment_method"`
	ClosingDay    *int32         `json:"closing_day"`
	PaymentDueDay *int32         `json:"payment_due_day"`
	InvoiceNumber *string        `json:"invoice_number"`
	IsActive      *bool          `json:"is_active"`
	ID            int32          `json:"id"`
}

// 取引先情報を更新
func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.db.Exec(ctx, updateCustomer,
		arg.Name,
		arg.CreditLimit,
		arg.PaymentTerms,
		arg.PaymentMethod,
		arg.ClosingDay,
		arg.PaymentDueDay,
		arg.InvoiceNumber,
		arg.IsActive,
		arg.ID,
	)
	return err
}

const updateCustomerContact = `-- name: UpdateCustomerContact :exec
UPDATE customer_contacts
SET
    last_name = COALESCE($1, last_name),
    first_name = COALESCE($2, first_name),
    last_name_kana = COALESCE($3, last_name_kana),
    first_name_kana = COALESCE($4, first_name_kana),
    department = COALESCE($5, department),
    position = COALESCE($6, position),
    email = COALESCE($7, email),
    phone_direct = COALESCE($8, phone_direct),
    phone_mobile = COALESCE($9, phone_mobile),
    is_primary = COALESCE($10, is_primary),
    notes = COALESCE($11, notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $12
`

type UpdateCustomerContactParams struct {
	LastName      *string `json:"last_name"`
	FirstName     *string `json:"first_name"`
	LastNameKana  *string `json:"last_name_kana"`
	FirstNameKana *string `json:"first_name_kana"`
	Department    *string `json:"department"`
	Position      *string `json:"position"`
	Email         *string `json:"email"`
	PhoneDirect   *string `json:"phone_direct"`
	PhoneMobile   *string `json:"phone_mobile"`
	IsPrimary     *bool   `json:"is_primary"`
	Notes         *string `json:"notes"`
	ID            int32   `json:"id"`
}

// 取引先担当者を更新
func (q *Queries) UpdateCustomerContact(ctx context.Context, arg UpdateCustomerContactParams) error {
	_, err := q.db.Exec(ctx, updateCustomerContact,
		arg.LastName,
		arg.FirstName,
		arg.LastNameKana,
		arg.FirstNameKana,
		arg.Department,
		arg.Position,
		arg.Email,
		arg.PhoneDirect,
		arg.PhoneMobile,
		arg.IsPrimary,
		arg.Notes,
		arg.ID,
	)
	return err
}
