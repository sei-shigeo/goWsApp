// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_orders.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const confirmBilling = `-- name: ConfirmBilling :exec
UPDATE delivery_orders
SET
    billing_confirmed = true,
    billing_confirmed_by = $2,
    billing_confirmed_at = CURRENT_TIMESTAMP,
    subtotal_amount = $3,
    tax_amount = $4,
    total_amount = $5,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type ConfirmBillingParams struct {
	ID                 int32          `json:"id"`
	BillingConfirmedBy *int32         `json:"billing_confirmed_by"`
	SubtotalAmount     pgtype.Numeric `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric `json:"tax_amount"`
	TotalAmount        pgtype.Numeric `json:"total_amount"`
}

// 経理確定処理
func (q *Queries) ConfirmBilling(ctx context.Context, arg ConfirmBillingParams) error {
	_, err := q.db.Exec(ctx, confirmBilling,
		arg.ID,
		arg.BillingConfirmedBy,
		arg.SubtotalAmount,
		arg.TaxAmount,
		arg.TotalAmount,
	)
	return err
}

const countDeliveryOrders = `-- name: CountDeliveryOrders :one
SELECT COUNT(*) as count
FROM delivery_orders
WHERE deleted_at IS NULL
AND ($1::text IS NULL OR order_status = $1)
`

// オーダー数をカウント
func (q *Queries) CountDeliveryOrders(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveryOrders, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeliveryAssignment = `-- name: CreateDeliveryAssignment :one

INSERT INTO delivery_assignments (
    order_id,
    detail_id,
    driver_id,
    driver_companion_id,
    vehicle_id,
    assigned_at,
    started_at,
    completed_at,
    cancelled_at,
    assignment_status,
    cancellation_reason,
    notes,
    assigned_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, order_id, detail_id, driver_id, driver_companion_id, vehicle_id, assigned_at, started_at, completed_at, cancelled_at, assignment_status, cancellation_reason, notes, assigned_by, created_at, updated_at
`

type CreateDeliveryAssignmentParams struct {
	OrderID            int32              `json:"order_id"`
	DetailID           *int32             `json:"detail_id"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	AssignedAt         pgtype.Timestamptz `json:"assigned_at"`
	StartedAt          pgtype.Timestamptz `json:"started_at"`
	CompletedAt        pgtype.Timestamptz `json:"completed_at"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	AssignmentStatus   *string            `json:"assignment_status"`
	CancellationReason *string            `json:"cancellation_reason"`
	Notes              *string            `json:"notes"`
	AssignedBy         *int32             `json:"assigned_by"`
}

// ==============================
// 配車履歴管理
// ==============================
// 配車履歴を記録
func (q *Queries) CreateDeliveryAssignment(ctx context.Context, arg CreateDeliveryAssignmentParams) (DeliveryAssignment, error) {
	row := q.db.QueryRow(ctx, createDeliveryAssignment,
		arg.OrderID,
		arg.DetailID,
		arg.DriverID,
		arg.DriverCompanionID,
		arg.VehicleID,
		arg.AssignedAt,
		arg.StartedAt,
		arg.CompletedAt,
		arg.CancelledAt,
		arg.AssignmentStatus,
		arg.CancellationReason,
		arg.Notes,
		arg.AssignedBy,
	)
	var i DeliveryAssignment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.DetailID,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.AssignedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CancelledAt,
		&i.AssignmentStatus,
		&i.CancellationReason,
		&i.Notes,
		&i.AssignedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDeliveryCharge = `-- name: CreateDeliveryCharge :one

INSERT INTO delivery_charges (
    order_id,
    detail_id,
    charge_type,
    charge_name,
    amount,
    tax_category,
    notes,
    receipt_image_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, order_id, detail_id, charge_type, charge_name, amount, tax_category, notes, receipt_image_url, created_at, updated_at
`

type CreateDeliveryChargeParams struct {
	OrderID         int32          `json:"order_id"`
	DetailID        *int32         `json:"detail_id"`
	ChargeType      *string        `json:"charge_type"`
	ChargeName      string         `json:"charge_name"`
	Amount          pgtype.Numeric `json:"amount"`
	TaxCategory     *string        `json:"tax_category"`
	Notes           *string        `json:"notes"`
	ReceiptImageUrl *string        `json:"receipt_image_url"`
}

// ==============================
// 追加料金管理
// ==============================
// 追加料金を登録
func (q *Queries) CreateDeliveryCharge(ctx context.Context, arg CreateDeliveryChargeParams) (DeliveryCharge, error) {
	row := q.db.QueryRow(ctx, createDeliveryCharge,
		arg.OrderID,
		arg.DetailID,
		arg.ChargeType,
		arg.ChargeName,
		arg.Amount,
		arg.TaxCategory,
		arg.Notes,
		arg.ReceiptImageUrl,
	)
	var i DeliveryCharge
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.DetailID,
		&i.ChargeType,
		&i.ChargeName,
		&i.Amount,
		&i.TaxCategory,
		&i.Notes,
		&i.ReceiptImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDeliveryDetail = `-- name: CreateDeliveryDetail :one

INSERT INTO delivery_details (
    order_id,
    line_number,
    route_from,
    route_to,
    driver_id,
    driver_companion_id,
    vehicle_id,
    trailer_id,
    departure_time,
    arrival_time,
    service_item_id,
    item_name,
    quantity,
    unit,
    unit_price,
    amount,
    tax_category,
    detail_notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING id, order_id, line_number, route_from, route_to, driver_id, driver_companion_id, vehicle_id, trailer_id, departure_time, arrival_time, service_item_id, item_name, quantity, unit, unit_price, amount, tax_category, detail_notes, created_at, updated_at
`

type CreateDeliveryDetailParams struct {
	OrderID           int32          `json:"order_id"`
	LineNumber        int32          `json:"line_number"`
	RouteFrom         *string        `json:"route_from"`
	RouteTo           *string        `json:"route_to"`
	DriverID          *int32         `json:"driver_id"`
	DriverCompanionID *int32         `json:"driver_companion_id"`
	VehicleID         *int32         `json:"vehicle_id"`
	TrailerID         *int32         `json:"trailer_id"`
	DepartureTime     pgtype.Time    `json:"departure_time"`
	ArrivalTime       pgtype.Time    `json:"arrival_time"`
	ServiceItemID     *int32         `json:"service_item_id"`
	ItemName          *string        `json:"item_name"`
	Quantity          pgtype.Numeric `json:"quantity"`
	Unit              *string        `json:"unit"`
	UnitPrice         pgtype.Numeric `json:"unit_price"`
	Amount            pgtype.Numeric `json:"amount"`
	TaxCategory       *string        `json:"tax_category"`
	DetailNotes       *string        `json:"detail_notes"`
}

// ==============================
// 配送明細管理
// ==============================
// 配送明細を登録
func (q *Queries) CreateDeliveryDetail(ctx context.Context, arg CreateDeliveryDetailParams) (DeliveryDetail, error) {
	row := q.db.QueryRow(ctx, createDeliveryDetail,
		arg.OrderID,
		arg.LineNumber,
		arg.RouteFrom,
		arg.RouteTo,
		arg.DriverID,
		arg.DriverCompanionID,
		arg.VehicleID,
		arg.TrailerID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.ServiceItemID,
		arg.ItemName,
		arg.Quantity,
		arg.Unit,
		arg.UnitPrice,
		arg.Amount,
		arg.TaxCategory,
		arg.DetailNotes,
	)
	var i DeliveryDetail
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.LineNumber,
		&i.RouteFrom,
		&i.RouteTo,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.TrailerID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.ServiceItemID,
		&i.ItemName,
		&i.Quantity,
		&i.Unit,
		&i.UnitPrice,
		&i.Amount,
		&i.TaxCategory,
		&i.DetailNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDeliveryOrder = `-- name: CreateDeliveryOrder :one

INSERT INTO delivery_orders (
    order_number,
    customer_id,
    service_type,
    service_type_id,
    order_date,
    operation_date,
    delivery_date,
    driver_id,
    driver_companion_id,
    vehicle_id,
    departure_time,
    arrival_time,
    has_highway_fee,
    has_extra_charge,
    is_tax_exempt,
    order_status,
    notes,
    created_by,
    assigned_to
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, order_number, customer_id, service_type, service_type_id, order_date, operation_date, delivery_date, driver_id, driver_companion_id, vehicle_id, departure_time, arrival_time, has_highway_fee, has_extra_charge, is_tax_exempt, order_status, billing_confirmed, billing_confirmed_by, billing_confirmed_at, revenue_date, revenue_month, revenue_locked, subtotal_amount, tax_amount, total_amount, invoice_issued, invoice_number, invoice_date, notes, created_by, assigned_to, is_active, created_at, updated_at, deleted_at
`

type CreateDeliveryOrderParams struct {
	OrderNumber       string      `json:"order_number"`
	CustomerID        int32       `json:"customer_id"`
	ServiceType       string      `json:"service_type"`
	ServiceTypeID     *int32      `json:"service_type_id"`
	OrderDate         pgtype.Date `json:"order_date"`
	OperationDate     pgtype.Date `json:"operation_date"`
	DeliveryDate      pgtype.Date `json:"delivery_date"`
	DriverID          *int32      `json:"driver_id"`
	DriverCompanionID *int32      `json:"driver_companion_id"`
	VehicleID         *int32      `json:"vehicle_id"`
	DepartureTime     pgtype.Time `json:"departure_time"`
	ArrivalTime       pgtype.Time `json:"arrival_time"`
	HasHighwayFee     *bool       `json:"has_highway_fee"`
	HasExtraCharge    *bool       `json:"has_extra_charge"`
	IsTaxExempt       *bool       `json:"is_tax_exempt"`
	OrderStatus       *string     `json:"order_status"`
	Notes             *string     `json:"notes"`
	CreatedBy         *int32      `json:"created_by"`
	AssignedTo        *int32      `json:"assigned_to"`
}

// ==============================
// 配送オーダー管理クエリ
// ==============================
// 配送オーダーを新規登録
func (q *Queries) CreateDeliveryOrder(ctx context.Context, arg CreateDeliveryOrderParams) (DeliveryOrder, error) {
	row := q.db.QueryRow(ctx, createDeliveryOrder,
		arg.OrderNumber,
		arg.CustomerID,
		arg.ServiceType,
		arg.ServiceTypeID,
		arg.OrderDate,
		arg.OperationDate,
		arg.DeliveryDate,
		arg.DriverID,
		arg.DriverCompanionID,
		arg.VehicleID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.HasHighwayFee,
		arg.HasExtraCharge,
		arg.IsTaxExempt,
		arg.OrderStatus,
		arg.Notes,
		arg.CreatedBy,
		arg.AssignedTo,
	)
	var i DeliveryOrder
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.ServiceType,
		&i.ServiceTypeID,
		&i.OrderDate,
		&i.OperationDate,
		&i.DeliveryDate,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.HasHighwayFee,
		&i.HasExtraCharge,
		&i.IsTaxExempt,
		&i.OrderStatus,
		&i.BillingConfirmed,
		&i.BillingConfirmedBy,
		&i.BillingConfirmedAt,
		&i.RevenueDate,
		&i.RevenueMonth,
		&i.RevenueLocked,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceIssued,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.Notes,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteDeliveryCharge = `-- name: DeleteDeliveryCharge :exec
DELETE FROM delivery_charges
WHERE id = $1
`

// 追加料金を削除
func (q *Queries) DeleteDeliveryCharge(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDeliveryCharge, id)
	return err
}

const deleteDeliveryDetail = `-- name: DeleteDeliveryDetail :exec
DELETE FROM delivery_details
WHERE id = $1
`

// 配送明細を削除
func (q *Queries) DeleteDeliveryDetail(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDeliveryDetail, id)
	return err
}

const deleteDeliveryOrder = `-- name: DeleteDeliveryOrder :exec
UPDATE delivery_orders
SET
    deleted_at = CURRENT_TIMESTAMP,
    order_status = 'キャンセル'
WHERE id = $1
`

// オーダーを論理削除
func (q *Queries) DeleteDeliveryOrder(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteDeliveryOrder, id)
	return err
}

const getDeliveryDetail = `-- name: GetDeliveryDetail :one
SELECT id, order_id, line_number, route_from, route_to, driver_id, driver_companion_id, vehicle_id, trailer_id, departure_time, arrival_time, service_item_id, item_name, quantity, unit, unit_price, amount, tax_category, detail_notes, created_at, updated_at
FROM delivery_details
WHERE id = $1
`

// 配送明細を取得
func (q *Queries) GetDeliveryDetail(ctx context.Context, id int32) (DeliveryDetail, error) {
	row := q.db.QueryRow(ctx, getDeliveryDetail, id)
	var i DeliveryDetail
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.LineNumber,
		&i.RouteFrom,
		&i.RouteTo,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.TrailerID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.ServiceItemID,
		&i.ItemName,
		&i.Quantity,
		&i.Unit,
		&i.UnitPrice,
		&i.Amount,
		&i.TaxCategory,
		&i.DetailNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDeliveryOrder = `-- name: GetDeliveryOrder :one
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    c.customer_code,
    e1.last_name || ' ' || e1.first_name as driver_name,
    e2.last_name || ' ' || e2.first_name as companion_name,
    v.vehicle_number,
    si.item_name as service_item_name
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
LEFT JOIN employees e1 ON ord.driver_id = e1.id
LEFT JOIN employees e2 ON ord.driver_companion_id = e2.id
LEFT JOIN vehicles v ON ord.vehicle_id = v.id
LEFT JOIN service_items si ON ord.service_type_id = si.id
WHERE ord.id = $1
AND ord.deleted_at IS NULL
`

type GetDeliveryOrderRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	CustomerCode       string             `json:"customer_code"`
	DriverName         interface{}        `json:"driver_name"`
	CompanionName      interface{}        `json:"companion_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
	ServiceItemName    *string            `json:"service_item_name"`
}

// 配送オーダーをIDで取得
func (q *Queries) GetDeliveryOrder(ctx context.Context, id int32) (GetDeliveryOrderRow, error) {
	row := q.db.QueryRow(ctx, getDeliveryOrder, id)
	var i GetDeliveryOrderRow
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.ServiceType,
		&i.ServiceTypeID,
		&i.OrderDate,
		&i.OperationDate,
		&i.DeliveryDate,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.HasHighwayFee,
		&i.HasExtraCharge,
		&i.IsTaxExempt,
		&i.OrderStatus,
		&i.BillingConfirmed,
		&i.BillingConfirmedBy,
		&i.BillingConfirmedAt,
		&i.RevenueDate,
		&i.RevenueMonth,
		&i.RevenueLocked,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceIssued,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.Notes,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CustomerName,
		&i.CustomerCode,
		&i.DriverName,
		&i.CompanionName,
		&i.VehicleNumber,
		&i.ServiceItemName,
	)
	return i, err
}

const getDeliveryOrderByNumber = `-- name: GetDeliveryOrderByNumber :one
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
WHERE ord.order_number = $1
AND ord.deleted_at IS NULL
`

type GetDeliveryOrderByNumberRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	CustomerCode       string             `json:"customer_code"`
}

// オーダー番号で取得
func (q *Queries) GetDeliveryOrderByNumber(ctx context.Context, orderNumber string) (GetDeliveryOrderByNumberRow, error) {
	row := q.db.QueryRow(ctx, getDeliveryOrderByNumber, orderNumber)
	var i GetDeliveryOrderByNumberRow
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.ServiceType,
		&i.ServiceTypeID,
		&i.OrderDate,
		&i.OperationDate,
		&i.DeliveryDate,
		&i.DriverID,
		&i.DriverCompanionID,
		&i.VehicleID,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.HasHighwayFee,
		&i.HasExtraCharge,
		&i.IsTaxExempt,
		&i.OrderStatus,
		&i.BillingConfirmed,
		&i.BillingConfirmedBy,
		&i.BillingConfirmedAt,
		&i.RevenueDate,
		&i.RevenueMonth,
		&i.RevenueLocked,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceIssued,
		&i.InvoiceNumber,
		&i.InvoiceDate,
		&i.Notes,
		&i.CreatedBy,
		&i.AssignedTo,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CustomerName,
		&i.CustomerCode,
	)
	return i, err
}

const getOrderTotalAmount = `-- name: GetOrderTotalAmount :one
SELECT 
    COALESCE(SUM(dd.amount), 0) + COALESCE(SUM(dc.amount), 0) as total
FROM delivery_details dd
LEFT JOIN delivery_charges dc ON dd.order_id = dc.order_id
WHERE dd.order_id = $1
`

// オーダーの合計金額を計算
func (q *Queries) GetOrderTotalAmount(ctx context.Context, orderID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getOrderTotalAmount, orderID)
	var total int32
	err := row.Scan(&total)
	return total, err
}

const getOrdersForBilling = `-- name: GetOrdersForBilling :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
WHERE ord.billing_confirmed = false
AND ord.order_status = '完了'
AND ord.deleted_at IS NULL
ORDER BY ord.operation_date
`

type GetOrdersForBillingRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	CustomerCode       string             `json:"customer_code"`
}

// 経理確定待ちのオーダー一覧
func (q *Queries) GetOrdersForBilling(ctx context.Context) ([]GetOrdersForBillingRow, error) {
	rows, err := q.db.Query(ctx, getOrdersForBilling)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersForBillingRow{}
	for rows.Next() {
		var i GetOrdersForBillingRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersForInvoice = `-- name: GetOrdersForInvoice :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.closing_day,
    c.payment_due_day
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
WHERE ord.customer_id = $1
AND ord.billing_confirmed = true
AND ord.invoice_issued = false
AND ord.revenue_date BETWEEN $2 AND $3
AND ord.deleted_at IS NULL
ORDER BY ord.revenue_date
`

type GetOrdersForInvoiceParams struct {
	CustomerID    int32       `json:"customer_id"`
	RevenueDate   pgtype.Date `json:"revenue_date"`
	RevenueDate_2 pgtype.Date `json:"revenue_date_2"`
}

type GetOrdersForInvoiceRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	ClosingDay         *int32             `json:"closing_day"`
	PaymentDueDay      *int32             `json:"payment_due_day"`
}

// 請求書発行対象オーダー一覧（取引先・期間指定）
func (q *Queries) GetOrdersForInvoice(ctx context.Context, arg GetOrdersForInvoiceParams) ([]GetOrdersForInvoiceRow, error) {
	rows, err := q.db.Query(ctx, getOrdersForInvoice, arg.CustomerID, arg.RevenueDate, arg.RevenueDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersForInvoiceRow{}
	for rows.Next() {
		var i GetOrdersForInvoiceRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ClosingDay,
			&i.PaymentDueDay,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueSummaryByCustomer = `-- name: GetRevenueSummaryByCustomer :many
SELECT 
    ord.customer_id,
    c.name as customer_name,
    c.customer_code,
    COUNT(*) as order_count,
    SUM(ord.total_amount) as total_revenue,
    SUM(ord.subtotal_amount) as total_subtotal,
    SUM(ord.tax_amount) as total_tax
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
WHERE ord.billing_confirmed = true
AND ord.deleted_at IS NULL
AND ($1::date IS NULL OR ord.revenue_date >= $1)
AND ($2::date IS NULL OR ord.revenue_date <= $2)
GROUP BY ord.customer_id, c.name, c.customer_code
ORDER BY total_revenue DESC
`

type GetRevenueSummaryByCustomerParams struct {
	Column1 pgtype.Date `json:"column_1"`
	Column2 pgtype.Date `json:"column_2"`
}

type GetRevenueSummaryByCustomerRow struct {
	CustomerID    int32  `json:"customer_id"`
	CustomerName  string `json:"customer_name"`
	CustomerCode  string `json:"customer_code"`
	OrderCount    int64  `json:"order_count"`
	TotalRevenue  int64  `json:"total_revenue"`
	TotalSubtotal int64  `json:"total_subtotal"`
	TotalTax      int64  `json:"total_tax"`
}

// 取引先別売上集計（期間指定）
func (q *Queries) GetRevenueSummaryByCustomer(ctx context.Context, arg GetRevenueSummaryByCustomerParams) ([]GetRevenueSummaryByCustomerRow, error) {
	rows, err := q.db.Query(ctx, getRevenueSummaryByCustomer, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevenueSummaryByCustomerRow{}
	for rows.Next() {
		var i GetRevenueSummaryByCustomerRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerCode,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalSubtotal,
			&i.TotalTax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueSummaryByMonth = `-- name: GetRevenueSummaryByMonth :many
SELECT 
    revenue_month,
    COUNT(*) as order_count,
    SUM(total_amount) as total_revenue,
    SUM(subtotal_amount) as total_subtotal,
    SUM(tax_amount) as total_tax
FROM delivery_orders
WHERE revenue_month IS NOT NULL
AND billing_confirmed = true
AND deleted_at IS NULL
AND ($1::text IS NULL OR revenue_month >= $1)
AND ($2::text IS NULL OR revenue_month <= $2)
GROUP BY revenue_month
ORDER BY revenue_month DESC
`

type GetRevenueSummaryByMonthParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

type GetRevenueSummaryByMonthRow struct {
	RevenueMonth  *string `json:"revenue_month"`
	OrderCount    int64   `json:"order_count"`
	TotalRevenue  int64   `json:"total_revenue"`
	TotalSubtotal int64   `json:"total_subtotal"`
	TotalTax      int64   `json:"total_tax"`
}

// 月別売上集計
func (q *Queries) GetRevenueSummaryByMonth(ctx context.Context, arg GetRevenueSummaryByMonthParams) ([]GetRevenueSummaryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getRevenueSummaryByMonth, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevenueSummaryByMonthRow{}
	for rows.Next() {
		var i GetRevenueSummaryByMonthRow
		if err := rows.Scan(
			&i.RevenueMonth,
			&i.OrderCount,
			&i.TotalRevenue,
			&i.TotalSubtotal,
			&i.TotalTax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const issueInvoice = `-- name: IssueInvoice :exec
UPDATE delivery_orders
SET
    invoice_issued = true,
    invoice_number = $2,
    invoice_date = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type IssueInvoiceParams struct {
	ID            int32       `json:"id"`
	InvoiceNumber *string     `json:"invoice_number"`
	InvoiceDate   pgtype.Date `json:"invoice_date"`
}

// 請求書発行
func (q *Queries) IssueInvoice(ctx context.Context, arg IssueInvoiceParams) error {
	_, err := q.db.Exec(ctx, issueInvoice, arg.ID, arg.InvoiceNumber, arg.InvoiceDate)
	return err
}

const listDeliveryAssignments = `-- name: ListDeliveryAssignments :many
SELECT 
    da.id, da.order_id, da.detail_id, da.driver_id, da.driver_companion_id, da.vehicle_id, da.assigned_at, da.started_at, da.completed_at, da.cancelled_at, da.assignment_status, da.cancellation_reason, da.notes, da.assigned_by, da.created_at, da.updated_at,
    e1.last_name || ' ' || e1.first_name as driver_name,
    e2.last_name || ' ' || e2.first_name as companion_name,
    v.vehicle_number,
    e3.last_name || ' ' || e3.first_name as assigned_by_name
FROM delivery_assignments da
LEFT JOIN employees e1 ON da.driver_id = e1.id
LEFT JOIN employees e2 ON da.driver_companion_id = e2.id
LEFT JOIN vehicles v ON da.vehicle_id = v.id
LEFT JOIN employees e3 ON da.assigned_by = e3.id
WHERE da.order_id = $1
ORDER BY da.assigned_at DESC
`

type ListDeliveryAssignmentsRow struct {
	ID                 int32              `json:"id"`
	OrderID            int32              `json:"order_id"`
	DetailID           *int32             `json:"detail_id"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	AssignedAt         pgtype.Timestamptz `json:"assigned_at"`
	StartedAt          pgtype.Timestamptz `json:"started_at"`
	CompletedAt        pgtype.Timestamptz `json:"completed_at"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	AssignmentStatus   *string            `json:"assignment_status"`
	CancellationReason *string            `json:"cancellation_reason"`
	Notes              *string            `json:"notes"`
	AssignedBy         *int32             `json:"assigned_by"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DriverName         interface{}        `json:"driver_name"`
	CompanionName      interface{}        `json:"companion_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
	AssignedByName     interface{}        `json:"assigned_by_name"`
}

// オーダーの配車履歴一覧
func (q *Queries) ListDeliveryAssignments(ctx context.Context, orderID int32) ([]ListDeliveryAssignmentsRow, error) {
	rows, err := q.db.Query(ctx, listDeliveryAssignments, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveryAssignmentsRow{}
	for rows.Next() {
		var i ListDeliveryAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.DetailID,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.AssignedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CancelledAt,
			&i.AssignmentStatus,
			&i.CancellationReason,
			&i.Notes,
			&i.AssignedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DriverName,
			&i.CompanionName,
			&i.VehicleNumber,
			&i.AssignedByName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryCharges = `-- name: ListDeliveryCharges :many
SELECT id, order_id, detail_id, charge_type, charge_name, amount, tax_category, notes, receipt_image_url, created_at, updated_at
FROM delivery_charges
WHERE order_id = $1
ORDER BY id
`

// オーダーの追加料金一覧
func (q *Queries) ListDeliveryCharges(ctx context.Context, orderID int32) ([]DeliveryCharge, error) {
	rows, err := q.db.Query(ctx, listDeliveryCharges, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeliveryCharge{}
	for rows.Next() {
		var i DeliveryCharge
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.DetailID,
			&i.ChargeType,
			&i.ChargeName,
			&i.Amount,
			&i.TaxCategory,
			&i.Notes,
			&i.ReceiptImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryDetails = `-- name: ListDeliveryDetails :many
SELECT 
    dd.id, dd.order_id, dd.line_number, dd.route_from, dd.route_to, dd.driver_id, dd.driver_companion_id, dd.vehicle_id, dd.trailer_id, dd.departure_time, dd.arrival_time, dd.service_item_id, dd.item_name, dd.quantity, dd.unit, dd.unit_price, dd.amount, dd.tax_category, dd.detail_notes, dd.created_at, dd.updated_at,
    e1.last_name || ' ' || e1.first_name as driver_name,
    e2.last_name || ' ' || e2.first_name as companion_name,
    v1.vehicle_number,
    v2.vehicle_number as trailer_number
FROM delivery_details dd
LEFT JOIN employees e1 ON dd.driver_id = e1.id
LEFT JOIN employees e2 ON dd.driver_companion_id = e2.id
LEFT JOIN vehicles v1 ON dd.vehicle_id = v1.id
LEFT JOIN vehicles v2 ON dd.trailer_id = v2.id
WHERE dd.order_id = $1
ORDER BY dd.line_number
`

type ListDeliveryDetailsRow struct {
	ID                int32              `json:"id"`
	OrderID           int32              `json:"order_id"`
	LineNumber        int32              `json:"line_number"`
	RouteFrom         *string            `json:"route_from"`
	RouteTo           *string            `json:"route_to"`
	DriverID          *int32             `json:"driver_id"`
	DriverCompanionID *int32             `json:"driver_companion_id"`
	VehicleID         *int32             `json:"vehicle_id"`
	TrailerID         *int32             `json:"trailer_id"`
	DepartureTime     pgtype.Time        `json:"departure_time"`
	ArrivalTime       pgtype.Time        `json:"arrival_time"`
	ServiceItemID     *int32             `json:"service_item_id"`
	ItemName          *string            `json:"item_name"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	Unit              *string            `json:"unit"`
	UnitPrice         pgtype.Numeric     `json:"unit_price"`
	Amount            pgtype.Numeric     `json:"amount"`
	TaxCategory       *string            `json:"tax_category"`
	DetailNotes       *string            `json:"detail_notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DriverName        interface{}        `json:"driver_name"`
	CompanionName     interface{}        `json:"companion_name"`
	VehicleNumber     *string            `json:"vehicle_number"`
	TrailerNumber     *string            `json:"trailer_number"`
}

// オーダーの明細一覧
func (q *Queries) ListDeliveryDetails(ctx context.Context, orderID int32) ([]ListDeliveryDetailsRow, error) {
	rows, err := q.db.Query(ctx, listDeliveryDetails, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveryDetailsRow{}
	for rows.Next() {
		var i ListDeliveryDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.LineNumber,
			&i.RouteFrom,
			&i.RouteTo,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.TrailerID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.ServiceItemID,
			&i.ItemName,
			&i.Quantity,
			&i.Unit,
			&i.UnitPrice,
			&i.Amount,
			&i.TaxCategory,
			&i.DetailNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DriverName,
			&i.CompanionName,
			&i.VehicleNumber,
			&i.TrailerNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryOrders = `-- name: ListDeliveryOrders :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    c.customer_code,
    e.last_name || ' ' || e.first_name as driver_name,
    v.vehicle_number
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
LEFT JOIN employees e ON ord.driver_id = e.id
LEFT JOIN vehicles v ON ord.vehicle_id = v.id
WHERE ord.deleted_at IS NULL
ORDER BY ord.operation_date DESC, ord.order_number DESC
LIMIT $1 OFFSET $2
`

type ListDeliveryOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListDeliveryOrdersRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	CustomerCode       string             `json:"customer_code"`
	DriverName         interface{}        `json:"driver_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
}

// 配送オーダー一覧
func (q *Queries) ListDeliveryOrders(ctx context.Context, arg ListDeliveryOrdersParams) ([]ListDeliveryOrdersRow, error) {
	rows, err := q.db.Query(ctx, listDeliveryOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveryOrdersRow{}
	for rows.Next() {
		var i ListDeliveryOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
			&i.DriverName,
			&i.VehicleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryOrdersByCustomer = `-- name: ListDeliveryOrdersByCustomer :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    e.last_name || ' ' || e.first_name as driver_name,
    v.vehicle_number
FROM delivery_orders ord
LEFT JOIN employees e ON ord.driver_id = e.id
LEFT JOIN vehicles v ON ord.vehicle_id = v.id
WHERE ord.customer_id = $1
AND ord.deleted_at IS NULL
ORDER BY ord.operation_date DESC
LIMIT $2 OFFSET $3
`

type ListDeliveryOrdersByCustomerParams struct {
	CustomerID int32 `json:"customer_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type ListDeliveryOrdersByCustomerRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	DriverName         interface{}        `json:"driver_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
}

// 取引先別オーダー一覧
func (q *Queries) ListDeliveryOrdersByCustomer(ctx context.Context, arg ListDeliveryOrdersByCustomerParams) ([]ListDeliveryOrdersByCustomerRow, error) {
	rows, err := q.db.Query(ctx, listDeliveryOrdersByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveryOrdersByCustomerRow{}
	for rows.Next() {
		var i ListDeliveryOrdersByCustomerRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.DriverName,
			&i.VehicleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryOrdersByDate = `-- name: ListDeliveryOrdersByDate :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    e.last_name || ' ' || e.first_name as driver_name,
    v.vehicle_number
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
LEFT JOIN employees e ON ord.driver_id = e.id
LEFT JOIN vehicles v ON ord.vehicle_id = v.id
WHERE ord.operation_date = $1
AND ord.deleted_at IS NULL
ORDER BY ord.departure_time, ord.order_number
`

type ListDeliveryOrdersByDateRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	DriverName         interface{}        `json:"driver_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
}

// 日付別オーダー一覧
func (q *Queries) ListDeliveryOrdersByDate(ctx context.Context, operationDate pgtype.Date) ([]ListDeliveryOrdersByDateRow, error) {
	rows, err := q.db.Query(ctx, listDeliveryOrdersByDate, operationDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveryOrdersByDateRow{}
	for rows.Next() {
		var i ListDeliveryOrdersByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.DriverName,
			&i.VehicleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockRevenue = `-- name: LockRevenue :exec
UPDATE delivery_orders
SET
    revenue_locked = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// 売上を確定（締め処理）
func (q *Queries) LockRevenue(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, lockRevenue, id)
	return err
}

const searchDeliveryOrders = `-- name: SearchDeliveryOrders :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name,
    c.customer_code,
    e.last_name || ' ' || e.first_name as driver_name,
    v.vehicle_number
FROM delivery_orders ord
JOIN customers c ON ord.customer_id = c.id
LEFT JOIN employees e ON ord.driver_id = e.id
LEFT JOIN vehicles v ON ord.vehicle_id = v.id
WHERE ord.deleted_at IS NULL
AND ($1::text IS NULL OR ord.order_number ILIKE '%' || $1 || '%')
AND ($2::integer IS NULL OR ord.customer_id = $2)
AND ($3::date IS NULL OR ord.operation_date >= $3)
AND ($4::date IS NULL OR ord.operation_date <= $4)
AND ($5::text IS NULL OR ord.order_status = $5)
AND ($6::text IS NULL OR ord.service_type = $6)
AND ($7::boolean IS NULL OR ord.billing_confirmed = $7)
ORDER BY ord.operation_date DESC, ord.order_number DESC
LIMIT $8 OFFSET $9
`

type SearchDeliveryOrdersParams struct {
	Column1 string      `json:"column_1"`
	Column2 int32       `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
	Column5 string      `json:"column_5"`
	Column6 string      `json:"column_6"`
	Column7 bool        `json:"column_7"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchDeliveryOrdersRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
	CustomerCode       string             `json:"customer_code"`
	DriverName         interface{}        `json:"driver_name"`
	VehicleNumber      *string            `json:"vehicle_number"`
}

// オーダーを検索
func (q *Queries) SearchDeliveryOrders(ctx context.Context, arg SearchDeliveryOrdersParams) ([]SearchDeliveryOrdersRow, error) {
	rows, err := q.db.Query(ctx, searchDeliveryOrders,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchDeliveryOrdersRow{}
	for rows.Next() {
		var i SearchDeliveryOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
			&i.DriverName,
			&i.VehicleNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setRevenueDate = `-- name: SetRevenueDate :exec
UPDATE delivery_orders
SET
    revenue_date = $2,
    revenue_month = TO_CHAR($2, 'YYYY-MM'),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type SetRevenueDateParams struct {
	ID          int32       `json:"id"`
	RevenueDate pgtype.Date `json:"revenue_date"`
}

// 売上計上日を設定
func (q *Queries) SetRevenueDate(ctx context.Context, arg SetRevenueDateParams) error {
	_, err := q.db.Exec(ctx, setRevenueDate, arg.ID, arg.RevenueDate)
	return err
}

const unlockRevenue = `-- name: UnlockRevenue :exec
UPDATE delivery_orders
SET
    revenue_locked = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// 売上確定を解除
func (q *Queries) UnlockRevenue(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, unlockRevenue, id)
	return err
}

const updateDeliveryAssignmentStatus = `-- name: UpdateDeliveryAssignmentStatus :exec
UPDATE delivery_assignments
SET
    assignment_status = $1,
    started_at = COALESCE($2, started_at),
    completed_at = COALESCE($3, completed_at),
    cancelled_at = COALESCE($4, cancelled_at),
    cancellation_reason = COALESCE($5, cancellation_reason),
    notes = COALESCE($6, notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $7
`

type UpdateDeliveryAssignmentStatusParams struct {
	AssignmentStatus   *string            `json:"assignment_status"`
	StartedAt          pgtype.Timestamptz `json:"started_at"`
	CompletedAt        pgtype.Timestamptz `json:"completed_at"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason *string            `json:"cancellation_reason"`
	Notes              *string            `json:"notes"`
	ID                 int32              `json:"id"`
}

// 配車ステータスを更新
func (q *Queries) UpdateDeliveryAssignmentStatus(ctx context.Context, arg UpdateDeliveryAssignmentStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryAssignmentStatus,
		arg.AssignmentStatus,
		arg.StartedAt,
		arg.CompletedAt,
		arg.CancelledAt,
		arg.CancellationReason,
		arg.Notes,
		arg.ID,
	)
	return err
}

const updateDeliveryCharge = `-- name: UpdateDeliveryCharge :exec
UPDATE delivery_charges
SET
    charge_type = COALESCE($1, charge_type),
    charge_name = COALESCE($2, charge_name),
    amount = COALESCE($3, amount),
    tax_category = COALESCE($4, tax_category),
    notes = COALESCE($5, notes),
    receipt_image_url = COALESCE($6, receipt_image_url),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $7
`

type UpdateDeliveryChargeParams struct {
	ChargeType      *string        `json:"charge_type"`
	ChargeName      *string        `json:"charge_name"`
	Amount          pgtype.Numeric `json:"amount"`
	TaxCategory     *string        `json:"tax_category"`
	Notes           *string        `json:"notes"`
	ReceiptImageUrl *string        `json:"receipt_image_url"`
	ID              int32          `json:"id"`
}

// 追加料金を更新
func (q *Queries) UpdateDeliveryCharge(ctx context.Context, arg UpdateDeliveryChargeParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryCharge,
		arg.ChargeType,
		arg.ChargeName,
		arg.Amount,
		arg.TaxCategory,
		arg.Notes,
		arg.ReceiptImageUrl,
		arg.ID,
	)
	return err
}

const updateDeliveryDetail = `-- name: UpdateDeliveryDetail :exec
UPDATE delivery_details
SET
    route_from = COALESCE($1, route_from),
    route_to = COALESCE($2, route_to),
    driver_id = COALESCE($3, driver_id),
    driver_companion_id = COALESCE($4, driver_companion_id),
    vehicle_id = COALESCE($5, vehicle_id),
    trailer_id = COALESCE($6, trailer_id),
    departure_time = COALESCE($7, departure_time),
    arrival_time = COALESCE($8, arrival_time),
    item_name = COALESCE($9, item_name),
    quantity = COALESCE($10, quantity),
    unit = COALESCE($11, unit),
    unit_price = COALESCE($12, unit_price),
    amount = COALESCE($13, amount),
    tax_category = COALESCE($14, tax_category),
    detail_notes = COALESCE($15, detail_notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $16
`

type UpdateDeliveryDetailParams struct {
	RouteFrom         *string        `json:"route_from"`
	RouteTo           *string        `json:"route_to"`
	DriverID          *int32         `json:"driver_id"`
	DriverCompanionID *int32         `json:"driver_companion_id"`
	VehicleID         *int32         `json:"vehicle_id"`
	TrailerID         *int32         `json:"trailer_id"`
	DepartureTime     pgtype.Time    `json:"departure_time"`
	ArrivalTime       pgtype.Time    `json:"arrival_time"`
	ItemName          *string        `json:"item_name"`
	Quantity          pgtype.Numeric `json:"quantity"`
	Unit              *string        `json:"unit"`
	UnitPrice         pgtype.Numeric `json:"unit_price"`
	Amount            pgtype.Numeric `json:"amount"`
	TaxCategory       *string        `json:"tax_category"`
	DetailNotes       *string        `json:"detail_notes"`
	ID                int32          `json:"id"`
}

// 配送明細を更新
func (q *Queries) UpdateDeliveryDetail(ctx context.Context, arg UpdateDeliveryDetailParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryDetail,
		arg.RouteFrom,
		arg.RouteTo,
		arg.DriverID,
		arg.DriverCompanionID,
		arg.VehicleID,
		arg.TrailerID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.ItemName,
		arg.Quantity,
		arg.Unit,
		arg.UnitPrice,
		arg.Amount,
		arg.TaxCategory,
		arg.DetailNotes,
		arg.ID,
	)
	return err
}

const updateDeliveryOrder = `-- name: UpdateDeliveryOrder :exec
UPDATE delivery_orders
SET
    customer_id = COALESCE($1, customer_id),
    service_type = COALESCE($2, service_type),
    service_type_id = COALESCE($3, service_type_id),
    operation_date = COALESCE($4, operation_date),
    delivery_date = COALESCE($5, delivery_date),
    driver_id = COALESCE($6, driver_id),
    driver_companion_id = COALESCE($7, driver_companion_id),
    vehicle_id = COALESCE($8, vehicle_id),
    departure_time = COALESCE($9, departure_time),
    arrival_time = COALESCE($10, arrival_time),
    has_highway_fee = COALESCE($11, has_highway_fee),
    has_extra_charge = COALESCE($12, has_extra_charge),
    is_tax_exempt = COALESCE($13, is_tax_exempt),
    order_status = COALESCE($14, order_status),
    notes = COALESCE($15, notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $16
`

type UpdateDeliveryOrderParams struct {
	CustomerID        *int32      `json:"customer_id"`
	ServiceType       *string     `json:"service_type"`
	ServiceTypeID     *int32      `json:"service_type_id"`
	OperationDate     pgtype.Date `json:"operation_date"`
	DeliveryDate      pgtype.Date `json:"delivery_date"`
	DriverID          *int32      `json:"driver_id"`
	DriverCompanionID *int32      `json:"driver_companion_id"`
	VehicleID         *int32      `json:"vehicle_id"`
	DepartureTime     pgtype.Time `json:"departure_time"`
	ArrivalTime       pgtype.Time `json:"arrival_time"`
	HasHighwayFee     *bool       `json:"has_highway_fee"`
	HasExtraCharge    *bool       `json:"has_extra_charge"`
	IsTaxExempt       *bool       `json:"is_tax_exempt"`
	OrderStatus       *string     `json:"order_status"`
	Notes             *string     `json:"notes"`
	ID                int32       `json:"id"`
}

// オーダー情報を更新
func (q *Queries) UpdateDeliveryOrder(ctx context.Context, arg UpdateDeliveryOrderParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryOrder,
		arg.CustomerID,
		arg.ServiceType,
		arg.ServiceTypeID,
		arg.OperationDate,
		arg.DeliveryDate,
		arg.DriverID,
		arg.DriverCompanionID,
		arg.VehicleID,
		arg.DepartureTime,
		arg.ArrivalTime,
		arg.HasHighwayFee,
		arg.HasExtraCharge,
		arg.IsTaxExempt,
		arg.OrderStatus,
		arg.Notes,
		arg.ID,
	)
	return err
}

const updateDeliveryOrderStatus = `-- name: UpdateDeliveryOrderStatus :exec
UPDATE delivery_orders
SET
    order_status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateDeliveryOrderStatusParams struct {
	ID          int32   `json:"id"`
	OrderStatus *string `json:"order_status"`
}

// オーダーステータスを更新
func (q *Queries) UpdateDeliveryOrderStatus(ctx context.Context, arg UpdateDeliveryOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryOrderStatus, arg.ID, arg.OrderStatus)
	return err
}
