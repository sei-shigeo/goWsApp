// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOrderToInvoice = `-- name: AddOrderToInvoice :exec
INSERT INTO invoice_orders (
    invoice_id,
    order_id
) VALUES (
    $1, $2
)
`

type AddOrderToInvoiceParams struct {
	InvoiceID int32 `json:"invoice_id"`
	OrderID   int32 `json:"order_id"`
}

// オーダーを請求書に追加
func (q *Queries) AddOrderToInvoice(ctx context.Context, arg AddOrderToInvoiceParams) error {
	_, err := q.db.Exec(ctx, addOrderToInvoice, arg.InvoiceID, arg.OrderID)
	return err
}

const countInvoices = `-- name: CountInvoices :one
SELECT COUNT(*) as count
FROM invoices
WHERE deleted_at IS NULL
AND ($1::text IS NULL OR payment_status = $1)
`

// 請求書数をカウント
func (q *Queries) CountInvoices(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoices, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one

INSERT INTO invoices (
    invoice_number,
    customer_id,
    billing_period_from,
    billing_period_to,
    closing_date,
    subtotal_amount,
    tax_amount,
    total_amount,
    invoice_date,
    issued_by,
    payment_due_date,
    payment_status,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, invoice_number, customer_id, billing_period_from, billing_period_to, closing_date, subtotal_amount, tax_amount, total_amount, invoice_date, issued_at, issued_by, payment_due_date, payment_status, payment_date, payment_amount, notes, created_at, updated_at, deleted_at
`

type CreateInvoiceParams struct {
	InvoiceNumber     string         `json:"invoice_number"`
	CustomerID        int32          `json:"customer_id"`
	BillingPeriodFrom pgtype.Date    `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date    `json:"billing_period_to"`
	ClosingDate       pgtype.Date    `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric `json:"tax_amount"`
	TotalAmount       pgtype.Numeric `json:"total_amount"`
	InvoiceDate       pgtype.Date    `json:"invoice_date"`
	IssuedBy          *int32         `json:"issued_by"`
	PaymentDueDate    pgtype.Date    `json:"payment_due_date"`
	PaymentStatus     *string        `json:"payment_status"`
	Notes             *string        `json:"notes"`
}

// ==============================
// 請求書管理クエリ
// ==============================
// 請求書を作成
func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.InvoiceNumber,
		arg.CustomerID,
		arg.BillingPeriodFrom,
		arg.BillingPeriodTo,
		arg.ClosingDate,
		arg.SubtotalAmount,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.InvoiceDate,
		arg.IssuedBy,
		arg.PaymentDueDate,
		arg.PaymentStatus,
		arg.Notes,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.BillingPeriodFrom,
		&i.BillingPeriodTo,
		&i.ClosingDate,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceDate,
		&i.IssuedAt,
		&i.IssuedBy,
		&i.PaymentDueDate,
		&i.PaymentStatus,
		&i.PaymentDate,
		&i.PaymentAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
UPDATE invoices
SET
    deleted_at = CURRENT_TIMESTAMP,
    payment_status = 'キャンセル'
WHERE id = $1
`

// 請求書を論理削除
func (q *Queries) DeleteInvoice(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInvoice, id)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code,
    e.last_name || ' ' || e.first_name as issued_by_name
FROM invoices i
JOIN customers c ON i.customer_id = c.id
LEFT JOIN employees e ON i.issued_by = e.id
WHERE i.id = $1
AND i.deleted_at IS NULL
`

type GetInvoiceRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
	IssuedByName      interface{}        `json:"issued_by_name"`
}

// 請求書を取得
func (q *Queries) GetInvoice(ctx context.Context, id int32) (GetInvoiceRow, error) {
	row := q.db.QueryRow(ctx, getInvoice, id)
	var i GetInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.BillingPeriodFrom,
		&i.BillingPeriodTo,
		&i.ClosingDate,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceDate,
		&i.IssuedAt,
		&i.IssuedBy,
		&i.PaymentDueDate,
		&i.PaymentStatus,
		&i.PaymentDate,
		&i.PaymentAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CustomerName,
		&i.CustomerCode,
		&i.IssuedByName,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM invoices i
JOIN customers c ON i.customer_id = c.id
WHERE i.invoice_number = $1
AND i.deleted_at IS NULL
`

type GetInvoiceByNumberRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
}

// 請求書番号で取得
func (q *Queries) GetInvoiceByNumber(ctx context.Context, invoiceNumber string) (GetInvoiceByNumberRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceByNumber, invoiceNumber)
	var i GetInvoiceByNumberRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.BillingPeriodFrom,
		&i.BillingPeriodTo,
		&i.ClosingDate,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceDate,
		&i.IssuedAt,
		&i.IssuedBy,
		&i.PaymentDueDate,
		&i.PaymentStatus,
		&i.PaymentDate,
		&i.PaymentAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CustomerName,
		&i.CustomerCode,
	)
	return i, err
}

const getInvoiceOrders = `-- name: GetInvoiceOrders :many
SELECT 
    ord.id, ord.order_number, ord.customer_id, ord.service_type, ord.service_type_id, ord.order_date, ord.operation_date, ord.delivery_date, ord.driver_id, ord.driver_companion_id, ord.vehicle_id, ord.departure_time, ord.arrival_time, ord.has_highway_fee, ord.has_extra_charge, ord.is_tax_exempt, ord.order_status, ord.billing_confirmed, ord.billing_confirmed_by, ord.billing_confirmed_at, ord.revenue_date, ord.revenue_month, ord.revenue_locked, ord.subtotal_amount, ord.tax_amount, ord.total_amount, ord.invoice_issued, ord.invoice_number, ord.invoice_date, ord.notes, ord.created_by, ord.assigned_to, ord.is_active, ord.created_at, ord.updated_at, ord.deleted_at,
    c.name as customer_name
FROM invoice_orders io
JOIN delivery_orders ord ON io.order_id = ord.id
JOIN customers c ON ord.customer_id = c.id
WHERE io.invoice_id = $1
ORDER BY ord.operation_date, ord.order_number
`

type GetInvoiceOrdersRow struct {
	ID                 int32              `json:"id"`
	OrderNumber        string             `json:"order_number"`
	CustomerID         int32              `json:"customer_id"`
	ServiceType        string             `json:"service_type"`
	ServiceTypeID      *int32             `json:"service_type_id"`
	OrderDate          pgtype.Date        `json:"order_date"`
	OperationDate      pgtype.Date        `json:"operation_date"`
	DeliveryDate       pgtype.Date        `json:"delivery_date"`
	DriverID           *int32             `json:"driver_id"`
	DriverCompanionID  *int32             `json:"driver_companion_id"`
	VehicleID          *int32             `json:"vehicle_id"`
	DepartureTime      pgtype.Time        `json:"departure_time"`
	ArrivalTime        pgtype.Time        `json:"arrival_time"`
	HasHighwayFee      *bool              `json:"has_highway_fee"`
	HasExtraCharge     *bool              `json:"has_extra_charge"`
	IsTaxExempt        *bool              `json:"is_tax_exempt"`
	OrderStatus        *string            `json:"order_status"`
	BillingConfirmed   *bool              `json:"billing_confirmed"`
	BillingConfirmedBy *int32             `json:"billing_confirmed_by"`
	BillingConfirmedAt pgtype.Timestamptz `json:"billing_confirmed_at"`
	RevenueDate        pgtype.Date        `json:"revenue_date"`
	RevenueMonth       *string            `json:"revenue_month"`
	RevenueLocked      *bool              `json:"revenue_locked"`
	SubtotalAmount     pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount          pgtype.Numeric     `json:"tax_amount"`
	TotalAmount        pgtype.Numeric     `json:"total_amount"`
	InvoiceIssued      *bool              `json:"invoice_issued"`
	InvoiceNumber      *string            `json:"invoice_number"`
	InvoiceDate        pgtype.Date        `json:"invoice_date"`
	Notes              *string            `json:"notes"`
	CreatedBy          *int32             `json:"created_by"`
	AssignedTo         *int32             `json:"assigned_to"`
	IsActive           *bool              `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
	CustomerName       string             `json:"customer_name"`
}

// 請求書に含まれるオーダー一覧
func (q *Queries) GetInvoiceOrders(ctx context.Context, invoiceID int32) ([]GetInvoiceOrdersRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceOrders, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceOrdersRow{}
	for rows.Next() {
		var i GetInvoiceOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.ServiceType,
			&i.ServiceTypeID,
			&i.OrderDate,
			&i.OperationDate,
			&i.DeliveryDate,
			&i.DriverID,
			&i.DriverCompanionID,
			&i.VehicleID,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.HasHighwayFee,
			&i.HasExtraCharge,
			&i.IsTaxExempt,
			&i.OrderStatus,
			&i.BillingConfirmed,
			&i.BillingConfirmedBy,
			&i.BillingConfirmedAt,
			&i.RevenueDate,
			&i.RevenueMonth,
			&i.RevenueLocked,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceIssued,
			&i.InvoiceNumber,
			&i.InvoiceDate,
			&i.Notes,
			&i.CreatedBy,
			&i.AssignedTo,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceSummaryByMonth = `-- name: GetInvoiceSummaryByMonth :many
SELECT 
    TO_CHAR(invoice_date, 'YYYY-MM') as invoice_month,
    COUNT(*) as invoice_count,
    SUM(total_amount) as total_billed,
    SUM(CASE WHEN payment_status = '入金済' THEN payment_amount ELSE 0 END) as total_paid,
    SUM(CASE WHEN payment_status IN ('発行済', '延滞') THEN total_amount ELSE 0 END) as total_unpaid
FROM invoices
WHERE invoice_date IS NOT NULL
AND deleted_at IS NULL
AND ($1::date IS NULL OR invoice_date >= $1)
AND ($2::date IS NULL OR invoice_date <= $2)
GROUP BY TO_CHAR(invoice_date, 'YYYY-MM')
ORDER BY invoice_month DESC
`

type GetInvoiceSummaryByMonthParams struct {
	Column1 pgtype.Date `json:"column_1"`
	Column2 pgtype.Date `json:"column_2"`
}

type GetInvoiceSummaryByMonthRow struct {
	InvoiceMonth string `json:"invoice_month"`
	InvoiceCount int64  `json:"invoice_count"`
	TotalBilled  int64  `json:"total_billed"`
	TotalPaid    int64  `json:"total_paid"`
	TotalUnpaid  int64  `json:"total_unpaid"`
}

// 月別請求書集計
func (q *Queries) GetInvoiceSummaryByMonth(ctx context.Context, arg GetInvoiceSummaryByMonthParams) ([]GetInvoiceSummaryByMonthRow, error) {
	rows, err := q.db.Query(ctx, getInvoiceSummaryByMonth, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceSummaryByMonthRow{}
	for rows.Next() {
		var i GetInvoiceSummaryByMonthRow
		if err := rows.Scan(
			&i.InvoiceMonth,
			&i.InvoiceCount,
			&i.TotalBilled,
			&i.TotalPaid,
			&i.TotalUnpaid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderInvoice = `-- name: GetOrderInvoice :one
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name
FROM invoice_orders io
JOIN invoices i ON io.invoice_id = i.id
JOIN customers c ON i.customer_id = c.id
WHERE io.order_id = $1
AND i.deleted_at IS NULL
`

type GetOrderInvoiceRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
}

// オーダーが含まれる請求書を取得
func (q *Queries) GetOrderInvoice(ctx context.Context, orderID int32) (GetOrderInvoiceRow, error) {
	row := q.db.QueryRow(ctx, getOrderInvoice, orderID)
	var i GetOrderInvoiceRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.CustomerID,
		&i.BillingPeriodFrom,
		&i.BillingPeriodTo,
		&i.ClosingDate,
		&i.SubtotalAmount,
		&i.TaxAmount,
		&i.TotalAmount,
		&i.InvoiceDate,
		&i.IssuedAt,
		&i.IssuedBy,
		&i.PaymentDueDate,
		&i.PaymentStatus,
		&i.PaymentDate,
		&i.PaymentAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CustomerName,
	)
	return i, err
}

const getOverdueInvoices = `-- name: GetOverdueInvoices :many
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code,
    CURRENT_DATE - i.payment_due_date as days_overdue
FROM invoices i
JOIN customers c ON i.customer_id = c.id
WHERE i.payment_status = '発行済'
AND i.payment_due_date < CURRENT_DATE
AND i.deleted_at IS NULL
ORDER BY i.payment_due_date
`

type GetOverdueInvoicesRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
	DaysOverdue       int32              `json:"days_overdue"`
}

// 延滞請求書一覧
func (q *Queries) GetOverdueInvoices(ctx context.Context) ([]GetOverdueInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getOverdueInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverdueInvoicesRow{}
	for rows.Next() {
		var i GetOverdueInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.BillingPeriodFrom,
			&i.BillingPeriodTo,
			&i.ClosingDate,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceDate,
			&i.IssuedAt,
			&i.IssuedBy,
			&i.PaymentDueDate,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.PaymentAmount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
			&i.DaysOverdue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnpaidInvoices = `-- name: GetUnpaidInvoices :many
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM invoices i
JOIN customers c ON i.customer_id = c.id
WHERE i.payment_status IN ('発行済', '延滞')
AND i.deleted_at IS NULL
ORDER BY i.payment_due_date
`

type GetUnpaidInvoicesRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
}

// 未払い請求書一覧
func (q *Queries) GetUnpaidInvoices(ctx context.Context) ([]GetUnpaidInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getUnpaidInvoices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnpaidInvoicesRow{}
	for rows.Next() {
		var i GetUnpaidInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.BillingPeriodFrom,
			&i.BillingPeriodTo,
			&i.ClosingDate,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceDate,
			&i.IssuedAt,
			&i.IssuedBy,
			&i.PaymentDueDate,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.PaymentAmount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const issueInvoiceRecord = `-- name: IssueInvoiceRecord :exec
UPDATE invoices
SET
    issued_at = CURRENT_TIMESTAMP,
    invoice_date = COALESCE(invoice_date, CURRENT_DATE),
    payment_status = '発行済',
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// 請求書を発行
func (q *Queries) IssueInvoiceRecord(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, issueInvoiceRecord, id)
	return err
}

const listInvoices = `-- name: ListInvoices :many
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM invoices i
JOIN customers c ON i.customer_id = c.id
WHERE i.deleted_at IS NULL
ORDER BY i.invoice_date DESC, i.invoice_number DESC
LIMIT $1 OFFSET $2
`

type ListInvoicesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListInvoicesRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
}

// 請求書一覧
func (q *Queries) ListInvoices(ctx context.Context, arg ListInvoicesParams) ([]ListInvoicesRow, error) {
	rows, err := q.db.Query(ctx, listInvoices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvoicesRow{}
	for rows.Next() {
		var i ListInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.BillingPeriodFrom,
			&i.BillingPeriodTo,
			&i.ClosingDate,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceDate,
			&i.IssuedAt,
			&i.IssuedBy,
			&i.PaymentDueDate,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.PaymentAmount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByCustomer = `-- name: ListInvoicesByCustomer :many
SELECT id, invoice_number, customer_id, billing_period_from, billing_period_to, closing_date, subtotal_amount, tax_amount, total_amount, invoice_date, issued_at, issued_by, payment_due_date, payment_status, payment_date, payment_amount, notes, created_at, updated_at, deleted_at
FROM invoices
WHERE customer_id = $1
AND deleted_at IS NULL
ORDER BY invoice_date DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByCustomerParams struct {
	CustomerID int32 `json:"customer_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

// 取引先別の請求書一覧
func (q *Queries) ListInvoicesByCustomer(ctx context.Context, arg ListInvoicesByCustomerParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.BillingPeriodFrom,
			&i.BillingPeriodTo,
			&i.ClosingDate,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceDate,
			&i.IssuedAt,
			&i.IssuedBy,
			&i.PaymentDueDate,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.PaymentAmount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPayment = `-- name: RecordPayment :exec
UPDATE invoices
SET
    payment_status = '入金済',
    payment_date = $2,
    payment_amount = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type RecordPaymentParams struct {
	ID            int32          `json:"id"`
	PaymentDate   pgtype.Date    `json:"payment_date"`
	PaymentAmount pgtype.Numeric `json:"payment_amount"`
}

// 入金を記録
func (q *Queries) RecordPayment(ctx context.Context, arg RecordPaymentParams) error {
	_, err := q.db.Exec(ctx, recordPayment, arg.ID, arg.PaymentDate, arg.PaymentAmount)
	return err
}

const removeOrderFromInvoice = `-- name: RemoveOrderFromInvoice :exec
DELETE FROM invoice_orders
WHERE invoice_id = $1 AND order_id = $2
`

type RemoveOrderFromInvoiceParams struct {
	InvoiceID int32 `json:"invoice_id"`
	OrderID   int32 `json:"order_id"`
}

// オーダーを請求書から削除
func (q *Queries) RemoveOrderFromInvoice(ctx context.Context, arg RemoveOrderFromInvoiceParams) error {
	_, err := q.db.Exec(ctx, removeOrderFromInvoice, arg.InvoiceID, arg.OrderID)
	return err
}

const searchInvoices = `-- name: SearchInvoices :many
SELECT 
    i.id, i.invoice_number, i.customer_id, i.billing_period_from, i.billing_period_to, i.closing_date, i.subtotal_amount, i.tax_amount, i.total_amount, i.invoice_date, i.issued_at, i.issued_by, i.payment_due_date, i.payment_status, i.payment_date, i.payment_amount, i.notes, i.created_at, i.updated_at, i.deleted_at,
    c.name as customer_name,
    c.customer_code
FROM invoices i
JOIN customers c ON i.customer_id = c.id
WHERE i.deleted_at IS NULL
AND ($1::text IS NULL OR i.invoice_number ILIKE '%' || $1 || '%')
AND ($2::integer IS NULL OR i.customer_id = $2)
AND ($3::date IS NULL OR i.invoice_date >= $3)
AND ($4::date IS NULL OR i.invoice_date <= $4)
AND ($5::text IS NULL OR i.payment_status = $5)
ORDER BY i.invoice_date DESC, i.invoice_number DESC
LIMIT $6 OFFSET $7
`

type SearchInvoicesParams struct {
	Column1 string      `json:"column_1"`
	Column2 int32       `json:"column_2"`
	Column3 pgtype.Date `json:"column_3"`
	Column4 pgtype.Date `json:"column_4"`
	Column5 string      `json:"column_5"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchInvoicesRow struct {
	ID                int32              `json:"id"`
	InvoiceNumber     string             `json:"invoice_number"`
	CustomerID        int32              `json:"customer_id"`
	BillingPeriodFrom pgtype.Date        `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date        `json:"billing_period_to"`
	ClosingDate       pgtype.Date        `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric     `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric     `json:"tax_amount"`
	TotalAmount       pgtype.Numeric     `json:"total_amount"`
	InvoiceDate       pgtype.Date        `json:"invoice_date"`
	IssuedAt          pgtype.Timestamptz `json:"issued_at"`
	IssuedBy          *int32             `json:"issued_by"`
	PaymentDueDate    pgtype.Date        `json:"payment_due_date"`
	PaymentStatus     *string            `json:"payment_status"`
	PaymentDate       pgtype.Date        `json:"payment_date"`
	PaymentAmount     pgtype.Numeric     `json:"payment_amount"`
	Notes             *string            `json:"notes"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
	CustomerName      string             `json:"customer_name"`
	CustomerCode      string             `json:"customer_code"`
}

// 請求書を検索
func (q *Queries) SearchInvoices(ctx context.Context, arg SearchInvoicesParams) ([]SearchInvoicesRow, error) {
	rows, err := q.db.Query(ctx, searchInvoices,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchInvoicesRow{}
	for rows.Next() {
		var i SearchInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.CustomerID,
			&i.BillingPeriodFrom,
			&i.BillingPeriodTo,
			&i.ClosingDate,
			&i.SubtotalAmount,
			&i.TaxAmount,
			&i.TotalAmount,
			&i.InvoiceDate,
			&i.IssuedAt,
			&i.IssuedBy,
			&i.PaymentDueDate,
			&i.PaymentStatus,
			&i.PaymentDate,
			&i.PaymentAmount,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CustomerName,
			&i.CustomerCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :exec
UPDATE invoices
SET
    billing_period_from = COALESCE($1, billing_period_from),
    billing_period_to = COALESCE($2, billing_period_to),
    closing_date = COALESCE($3, closing_date),
    subtotal_amount = COALESCE($4, subtotal_amount),
    tax_amount = COALESCE($5, tax_amount),
    total_amount = COALESCE($6, total_amount),
    invoice_date = COALESCE($7, invoice_date),
    payment_due_date = COALESCE($8, payment_due_date),
    payment_status = COALESCE($9, payment_status),
    notes = COALESCE($10, notes),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $11
`

type UpdateInvoiceParams struct {
	BillingPeriodFrom pgtype.Date    `json:"billing_period_from"`
	BillingPeriodTo   pgtype.Date    `json:"billing_period_to"`
	ClosingDate       pgtype.Date    `json:"closing_date"`
	SubtotalAmount    pgtype.Numeric `json:"subtotal_amount"`
	TaxAmount         pgtype.Numeric `json:"tax_amount"`
	TotalAmount       pgtype.Numeric `json:"total_amount"`
	InvoiceDate       pgtype.Date    `json:"invoice_date"`
	PaymentDueDate    pgtype.Date    `json:"payment_due_date"`
	PaymentStatus     *string        `json:"payment_status"`
	Notes             *string        `json:"notes"`
	ID                int32          `json:"id"`
}

// 請求書を更新
func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) error {
	_, err := q.db.Exec(ctx, updateInvoice,
		arg.BillingPeriodFrom,
		arg.BillingPeriodTo,
		arg.ClosingDate,
		arg.SubtotalAmount,
		arg.TaxAmount,
		arg.TotalAmount,
		arg.InvoiceDate,
		arg.PaymentDueDate,
		arg.PaymentStatus,
		arg.Notes,
		arg.ID,
	)
	return err
}
