// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: service_items.sql

package db

import (
	"context"
)

const countServiceItems = `-- name: CountServiceItems :one
SELECT COUNT(*) as count
FROM service_items
WHERE deleted_at IS NULL
AND ($1::text IS NULL OR service_type = $1)
`

// サービス品名数をカウント
func (q *Queries) CountServiceItems(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countServiceItems, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createServiceItem = `-- name: CreateServiceItem :one

INSERT INTO service_items (
    service_type,
    item_name
) VALUES (
    $1, $2
) RETURNING id, service_type, item_name, created_at, updated_at, deleted_at
`

type CreateServiceItemParams struct {
	ServiceType *string `json:"service_type"`
	ItemName    string  `json:"item_name"`
}

// ==============================
// サービス品名マスタークエリ
// ==============================
// サービス品名を登録
func (q *Queries) CreateServiceItem(ctx context.Context, arg CreateServiceItemParams) (ServiceItem, error) {
	row := q.db.QueryRow(ctx, createServiceItem, arg.ServiceType, arg.ItemName)
	var i ServiceItem
	err := row.Scan(
		&i.ID,
		&i.ServiceType,
		&i.ItemName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteServiceItem = `-- name: DeleteServiceItem :exec
UPDATE service_items
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// サービス品名を論理削除
func (q *Queries) DeleteServiceItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteServiceItem, id)
	return err
}

const getServiceItem = `-- name: GetServiceItem :one
SELECT id, service_type, item_name, created_at, updated_at, deleted_at
FROM service_items
WHERE id = $1
AND deleted_at IS NULL
`

// サービス品名を取得
func (q *Queries) GetServiceItem(ctx context.Context, id int32) (ServiceItem, error) {
	row := q.db.QueryRow(ctx, getServiceItem, id)
	var i ServiceItem
	err := row.Scan(
		&i.ID,
		&i.ServiceType,
		&i.ItemName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listServiceItems = `-- name: ListServiceItems :many
SELECT id, service_type, item_name, created_at, updated_at, deleted_at
FROM service_items
WHERE deleted_at IS NULL
ORDER BY service_type, item_name
`

// サービス品名一覧
func (q *Queries) ListServiceItems(ctx context.Context) ([]ServiceItem, error) {
	rows, err := q.db.Query(ctx, listServiceItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceItem{}
	for rows.Next() {
		var i ServiceItem
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.ItemName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServiceItemsByType = `-- name: ListServiceItemsByType :many
SELECT id, service_type, item_name, created_at, updated_at, deleted_at
FROM service_items
WHERE service_type = $1
AND deleted_at IS NULL
ORDER BY item_name
`

// サービスタイプ別の品名一覧
func (q *Queries) ListServiceItemsByType(ctx context.Context, serviceType *string) ([]ServiceItem, error) {
	rows, err := q.db.Query(ctx, listServiceItemsByType, serviceType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceItem{}
	for rows.Next() {
		var i ServiceItem
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.ItemName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServiceItems = `-- name: SearchServiceItems :many
SELECT id, service_type, item_name, created_at, updated_at, deleted_at
FROM service_items
WHERE deleted_at IS NULL
AND (
    $1::text IS NULL 
    OR item_name ILIKE '%' || $1 || '%'
)
AND ($2::text IS NULL OR service_type = $2)
ORDER BY service_type, item_name
`

type SearchServiceItemsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

// サービス品名を検索
func (q *Queries) SearchServiceItems(ctx context.Context, arg SearchServiceItemsParams) ([]ServiceItem, error) {
	rows, err := q.db.Query(ctx, searchServiceItems, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ServiceItem{}
	for rows.Next() {
		var i ServiceItem
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
			&i.ItemName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServiceItem = `-- name: UpdateServiceItem :exec
UPDATE service_items
SET
    service_type = COALESCE($1, service_type),
    item_name = COALESCE($2, item_name),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $3
`

type UpdateServiceItemParams struct {
	ServiceType *string `json:"service_type"`
	ItemName    *string `json:"item_name"`
	ID          int32   `json:"id"`
}

// サービス品名を更新
func (q *Queries) UpdateServiceItem(ctx context.Context, arg UpdateServiceItemParams) error {
	_, err := q.db.Exec(ctx, updateServiceItem, arg.ServiceType, arg.ItemName, arg.ID)
	return err
}
